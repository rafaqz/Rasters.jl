var documenterSearchIndex = {"docs":
[{"location":"#Rasters.jl","page":"Rasters.jl","title":"Rasters.jl","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters","category":"page"},{"location":"#Rasters","page":"Rasters.jl","title":"Rasters","text":"Rasters\n\n(Image: ) (Image: ) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nRasters.jl defines common types and methods for reading, writing and manipulating rasterized spatial data. \n\nThese currently include raster arrays like GeoTIFF and NetCDF, R grd files,  multi-layered stacks, and multi-file series of arrays and stacks. \n\n(Image: EarthEnv HabitatHeterogeneity layers trimmed to Australia)\n\nA RasterStack of EarthEnv HabitatHeterogeneity layers, trimmed to Australia and plotted with Plots.jl\n\nLazyness\n\nData is loaded lazily wherever possible using DiskArrays.jl. Indexing a RasterStack by name is always lazy, while view of a Raster is lazy and getindex will load to memory. read can be used on any object to ensure that all data is loaded to memory.\nBroadcast over disk-based objects is lazy - it will only run when the array is indexed. Always prefer broadcasts to explicit loops - these can be very slow with disk-based data.\n\nData-source abstraction\n\nRasters provides a standardised interface that allows many source data types to be used with identical syntax.\n\nScripts and packages building on Rasters.jl can treat AbstractRaster, AbstractRasterStack, and AbstrackRasterSeries as black boxes.\nThe data could hold GeoTiff or NetCDF files, Arrays in memory or CuArrays on the GPU - they will all behave in the same way.\nRasterStack can be backed by a Netcdf or HDF5 file, or a NamedTuple of Raster holding .tif files, or all Raster in memory.\nUsers do not have to deal with the specifics of spatial file types.\nProjected lookups with Cylindrical projections can by indexed using other Cylindrical projections by setting the mappedcrs keyword on construction. You don't need to know the underlying projection, the conversion is handled automatically. This means lat/lon EPSG(4326) can be used seamlessly if you need that.\nRegions and points selected with Between and Contains select the right point or whole interval no matter the order of the index or it's position in the cell.\n\nNamed dimensions and index lookups\n\nRasters.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like X, Y and Ti (time) and e.g. spatial coordinates.\n\nDimensions can also be used in most Base and Statistics methods like mean and reduce where dims arguments are required. Much of the behaviour is covered in the DimensionalData docs.\n\nSee the docs for more details and examples for Rasters.jl.\n\n\n\n\n\n","category":"module"},{"location":"#Common-Applications","page":"Rasters.jl","title":"Common Applications","text":"","category":"section"},{"location":"#Subsetting-an-object","page":"Rasters.jl","title":"Subsetting an object","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Regular getindex (e.g. A[1:100, :]) and view work on all objects just as with an Array. view is always lazy, and reads from disk are deferred until getindex is used. DimensionalData.jl Dimensions and Selectors are the other way to subset an object, making use of the objects index to find values at  e.g. certain X/Y coordinates. The available selectors are listed here:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nAt(x) get the index exactly matching the passed in value(s)\nNear(x) get the closest index to the passed in value(s)\nWhere(f::Function) filter the array axis by a function of the dimension index values.\nBetween(a, b) get all indices between two values, excluding the high value.\nContains(x) get indices where the value x falls within an interval","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Use the Between selector to take a view of madagascar:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, Plots\nA = Raster(WorldClim{BioClim}, 5)\nmadagascar = view(A, X(Between(43.25, 50.48)), Y(Between(-25.61, -12.04))) \nplot(madagascar)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Methods that change the reslolution or extent of an object are listed here. Click through to the function documentation for more in-depth descriptions and examples.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \naggregate aggregate data by the same or different amounts for each axis.\ndisaggregate similarly disaggregate data.\nmosaic join rasters covering different extents into a single array or file.\ncrop shrink objects to specific dimension sizes or the extent of another object.\nextend extend objects to specific dimension sizes or the extent of another object.\ntrim trims areas of missing values for arrays and across stack layers.\nresample resample data to a different size and projection, or snap to another object.\nwarp use gdalwarp on any object, e.g. a multidimensional NetCDF stack.","category":"page"},{"location":"#Methods-that-change-an-objects-values:","page":"Rasters.jl","title":"Methods that change an objects values:","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Note that most regular Julia methods, such as replace, work as for a standard Array. These additional methods are commonly required in GIS applications.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nclassify classify values into categories.\nmask mask and object by a polygon or Raster along X/Y, or other dimensions.\nreplace_missing replace all missing values in an object and update missingval.","category":"page"},{"location":"#Point,-polygon-and-table-operation","page":"Rasters.jl","title":"Point, polygon and table operation","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nrasterize rasterize point and tabular data, or polygons.\nextract extract values using points or tables.\ninpolygon find if a point or points are in a polygon.","category":"page"},{"location":"#Methods-to-load,-write-and-modify-data-sources:","page":"Rasters.jl","title":"Methods to load, write and modify data sources:","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nmodify replace the data in objects. Useful to e.g. move objects to/from a GPU.\nread read data to memory if it is on disk.\nread! read data to predefined memory.\nopen open the underlying data for manually reading or writing.\nwrite write objects to file.","category":"page"},{"location":"#Altering-and-summarising-arrays-and-stacks-with-regular-julia-methods","page":"Rasters.jl","title":"Altering and summarising arrays and stacks with regular julia methods","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Most base methods work as for regular julia Arrays, such as reverse and rotations like rotl90. Base, statistics and linear algebra methods like mean that take a dims argument can also use the dimension name. To take the mean over the time dimension:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mean(A, dims=Ti)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"broadcast works lazily from disk, and is only applied when data is directly indexed. Adding a dot to any function will use broadcast over a Raster. ","category":"page"},{"location":"#Broadcasting","page":"Rasters.jl","title":"Broadcasting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"For a disk-based array A, this will only be applied when indexing occurs or when we read the array.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A .*= 2","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"To broadcast directly to disk, we need to open the file in write mode:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"open(Raster(filename); write=true) do O\n    O .*= 2\nend","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"To broadcast over a RasterStack use map, which applies a function to the layers of the stack - here A.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"newstack = map(stack) do A\n    A .* 2\nend","category":"page"},{"location":"#Modifying-object-properties","page":"Rasters.jl","title":"Modifying object properties","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild can be used to modify the fields of an object, generating a new object (but possibly holding the same arrays or files).","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"If you know that a file had an incorrectly specified missing value, you can do:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild(A; missingval=-9999)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"(replace_missing will actualy replace the current values)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Or if you need to change the name of the layer:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild(A; name=:temperature)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set can be used to modify the nested properties of an objects dimensions, that are more difficult to change with rebuild. set works on the principal that dimension properties can only be in one specific field, so we generally don't have to specify which one it is. set will also try to update anything affected by a change you make.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"This will set the X axis to specify points, instead of intervals:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set(A, X => Points)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"We can also reassign dimensions, here X becomes Z:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set(A, X => Z)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"setcrs(A, crs) and setmappedcrs(A, crs) will set the crs value/s of and object to any GeoFormat from GeoFormatTypes.jl.","category":"page"},{"location":"#Examples-and-Plotting","page":"Rasters.jl","title":"Examples and Plotting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plots.jl is fully supported by Rasters.jl, with recipes for plotting Raster and RasterStack provided. plot will plot a heatmap with axes matching dimension values. If mappedcrs is used, converted values will be shown on axes instead of the underlying crs values. contourf will similarly plot a filled contour plot.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Pixel resolution is limited to allow loading very large files quickly. max_res  specifies the maximum pixel resolution to show on the longest axis of the array. It can be set manually to change the resolution (e.g. for large or high-quality plots):","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, Plots\nA = Raster(WorldClim{BioClim}, 5)\nplot(A; max_res=3000)","category":"page"},{"location":"#Loading-and-plotting-data","page":"Rasters.jl","title":"Loading and plotting data","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Our first example simply loads a file from disk and plots it.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"This netcdf file only has one layer, if it has more we could use RasterStack instead. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, Plots\nurl = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Objects with Dimensions other than X an Y will produce multi-pane plots. Here we plot every third month in the first year, just using the regular index:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A[Ti(1:3:12)] |> plot","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now plot the ocean temperatures areound the Americas in the first month of 2001. Notice we are using lat/lon coordinates and date/time instead of regular indexes: The time dimension uses DateTime360Day, so we need to load CFTime.jl to index it with Near.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CFTime\nA[Ti(Near(DateTime360Day(2001, 01, 17))), \n  Y(Between(-60.0, 90.0)), \n  X(Between(190.0, 345.0))] |> plot","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now get the mean over the timespan, then save it to disk, and plot it as a filled contour:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Other plot functions and sliced objects that have only one X/Y/Z dimension fall back to generic DimensionalData.jl plotting, which will still correctly label plot axes.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Statistics\n# Take the mean\nmean_tos = mean(A; dims=Ti)","category":"page"},{"location":"#Plot-a-contour-plot","page":"Rasters.jl","title":"Plot a contour plot","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"contourf(mean_tos; dpi=300, size=(800, 400))","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Write the mean values to disk","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"write(\"mean_tos.nc\", mean_tos)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plotting recipes in DimensionalData.jl are the fallback for Rasters.jl when the object doesn't have 2 X/Y/Z dimensions, or a non-spatial plot command is used. So (as a random example) we could plot a transect of ocean surface temperature at 20 degree latitude :","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A[Y(Near(20.0)), Ti(1)] |> plot","category":"page"},{"location":"#A-basic-species-distribution-modelling-workflow","page":"Rasters.jl","title":"A basic species distribution modelling workflow","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Load occurrences for the Mountain Pygmy Possum using GBIF.jl","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, GBIF, Plots \nrecords = GBIF.occurrences(\"scientificName\" => \"Burramys parvus\", \"limit\" => 300)\n\n# Get the rest of the occurrences, we need to do this manually with a loop.\n# Note: GBIF.jl uses non-standard semantics for `size`. This is comparing \n# the occurrances already downloaded with the total occurrances.\nwhile length(records) < size(records)\n    occurrences!(records)\nend","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Extract the longitude/latitude value to a Vector of Tuple:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"coords = map(r -> (r.longitude, r.latitude), records)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Get BioClim layers and subset to south-east australia","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A = RasterStack(WorldClim{BioClim}, (1, 3, 7, 12))\nSE_aus = A[X=Between(138, 155), Y=Between(-40, -25), Band=1]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And plot BioClim predictors and scatter occurrence points on all subplots","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"p = plot(SE_aus);\nforeach(i -> scatter!(p, coords; subplot=i, legend=:none), 1:4)\np","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Then extract predictor variables and write to CSV.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CSV\npredictors = extract(SE_aus, coords)\nCSV.write(\"burramys_parvus_predictors.csv\", predictors)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Or convert them to a DataFrame.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using DataFrames\ndf = DataFrame(predictors)\ndf[1:5, :]","category":"page"},{"location":"#Polygon-masking,-mosaic-and-plot","page":"Rasters.jl","title":"Polygon masking, mosaic and plot","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"In this example we wil l mask the scandinavian countries with border polygons, then mosaic together to make a single plot. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"First, get the country boundary shape files using GADM.jl.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, Shapefile, Plots, Dates, Downloads\n\n# Download the shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary_lines.shp\"\nDownloads.download(shapefile_url, shapefile_name)\n\n# Load using Shapefile.jl\nshapes = Shapefile.Handle(shapefile_name)\ndenmark_border = shapes.shapes[71]\nnorway_border = shapes.shapes[53]\nsweden_border = shapes.shapes[54]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Then load raster data. We load some worldclim layers using RasterDataSources via Rasters.jl, and drop the Band dimension.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"climate = RasterStack(WorldClim{Climate}, (:tmin, :tmax, :prec, :wind); month=July)[Band(1)]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mask denmark, norway and sweden from the global dataset using their border polygon, then trim the missing values. We pad trim with a 10 pixel margin.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mask_trim(climate, poly) = trim(mask(climate; with=poly); pad=10)\n\ndenmark = mask_trim(climate, denmark_border)\nnorway = mask_trim(climate, norway_border)\nsweden = mask_trim(climate, sweden_border)","category":"page"},{"location":"#Plotting","page":"Rasters.jl","title":"Plotting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"First define a function to add borders to all subplots.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"function borders!(p, poly) \n    for i in 1:length(p)\n        plot!(p, poly; subplot=i, fillalpha=0, linewidth=0.6)\n    end\n    return p\nend","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now we can plot the individual countries.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"dp = plot(denmark)\nborders!(dp, denmark_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"sp = plot(sweden)\nborders!(sp, sweden_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"np = plot(norway)\nborders!(np, norway_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"The Norway shape includes a lot of islands. Lets crop them out using Between.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"norway_region = climate[X=Between(0, 40), Y=Between(55, 73)]\nplot(norway_region)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And mask it with the border again:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"norway = mask_trim(norway_region, norway_border)\nnp = plot(norway)\nborders!(np, norway_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now we can combine the countries into a single raster using mosaic. first will take the first value if/when there is an overlap.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"scandinavia = mosaic(first, denmark, norway, sweden)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And plot scandinavia, with all borders included:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"p = plot(scandinavia)\nborders!(p, denmark_border)\nborders!(p, norway_border)\nborders!(p, sweden_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And save to netcdf - a single multi-layered file, and tif, which will write a file for each stack layer.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"write(\"scandinavia.nc\", scandinavia)\nwrite(\"scandinavia.tif\", scandinavia)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl provides a range of other methods that are being added to over time. Where applicable these methods read and write lazily to and from disk-based arrays of common raster file types. These methods also work for entire RasterStacks and RasterSeries using the same syntax.","category":"page"},{"location":"#Objects","page":"Rasters.jl","title":"Objects","text":"","category":"section"},{"location":"#Raster","page":"Rasters.jl","title":"Raster","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Spatial raster data is essentially just an Array. But Raster wrappers allow treating them as an array that maintains its spatial index, crs and other metadata through all transformations. This means the can always be plotted and written to disk after applying most base Julia methods, and most broadcasts.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRaster\nRaster\nRaster(T::Type{<:RasterDataSources.RasterDataSource}, layer)","category":"page"},{"location":"#Rasters.AbstractRaster","page":"Rasters.jl","title":"Rasters.AbstractRaster","text":"AbstractRaster <: DimensionalData.AbstractDimArray\n\nAbstract supertype for objects that wrap an array (or location of an array)  and metadata about its contents. It may be memory or hold a FileArray, which holds the filename, and is only opened when required.\n\nAbstractRasters inherit from AbstractDimArray from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl Dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with getindex or view. getindex on a AbstractRaster will always return a memory-backed Raster.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Raster","page":"Rasters.jl","title":"Rasters.Raster","text":"Raster <: AbsractRaster\n\nRaster(filepath::AbstractString, dims; kw...)\nRaster(A::AbstractArray{T,N}, dims; kw...)\nRaster(A::AbstractRaster; kw...)\n\nA generic AbstractRaster for spatial/raster array data. It may hold memory-backed arrays or FileArray, that simply holds the String path to an unopened file. This will only be opened lazily when it is indexed with getindex or when read(A) is called. Broadcasting, taking a view, reversing and most other  methods do not load data from disk: they are applied later, lazily.\n\nKeywords\n\ndata: can replace the data in an AbstractRaster\ndims: Tuple of Dimensions for the array.\nrefdims: Tuple of position Dimensions the array was sliced from, defaulting to ().\nkey: Symbol key to desired layer in a multi-layer dataset, when a filpath is used.\nname: Symbol name for the array. key is used by default when a filepath String is pased in.\nmissingval: value reprsenting missing data, normally detected form the file. Set manually   when you know the value is not specified or is incorrect. This will not change any   values in the raster, it simply assigns which value is treated as missing. To replace all of   the missing values in the raster, use replace_missing.\nmetadata: ArrayMetadata object for the array, or NoMetadata().\ncrs: the coordinate reference system of  the objects XDim/YDim dimensions.    Only set this if you know the detected crs is incrorrect, or it is not present in   the file.\nmappedcrs: the mapped coordinate reference system of the objects XDim/YDim dimensions.   for Mapped lookups these are the actual values of the index. For Projected lookups   this can be used to index in eg. EPSG(4326) lat/lon values, having it converted automatically.   Only set this if the detected mappedcrs in incorrect, or the file does not have a mappedcrs,   e.g. a tiff.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Raster-Tuple{Type{<:RasterDataSources.RasterDataSource}, Any}","page":"Rasters.jl","title":"Rasters.Raster","text":"Raster(T::Type{<:RasterDataSource}, [layer]; kw...) => Raster\n\nLoad a RasterDataSource as an Raster. T and layers are are passed to RasterDataSources.getraster, while kw args are for both getraster and Raster.\n\nKeywords\n\nmonth: an Int between 1 and 12, usually for Climate datasets\ndate: a DateTime object, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nOther Raster keywords are passed to the Raster constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#RasterStack","page":"Rasters.jl","title":"RasterStack","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Spatial data often comes as a bundle of multiple named arrays, as in netcdf. RasterStack can represent this, or multiple files organised in a similar way.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRasterStack\nRasterStack\nRasterStack(T::Type{<:RasterDataSources.RasterDataSource})","category":"page"},{"location":"#Rasters.AbstractRasterStack","page":"Rasters.jl","title":"Rasters.AbstractRasterStack","text":"AbstractRasterStack\n\nAbstract supertype for objects that hold multiple AbstractRaster that share spatial dimensions.\n\nThey are NamedTuple-like structures that may either contain NamedTuple of AbstractRaster, string paths that will load AbstractRaster, or a single path that points to as a file itself containing multiple layers, like NetCDF or HDF5. Use and syntax is similar or identical for all cases.\n\nAbstractRasterStack can hold layers that share some or all of their dimensions. They cannot have the same dimension with t different length or spatial extent as another layer.\n\ngetindex on a AbstractRasterStack generally returns a memory backed standard Raster. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, X(1:100), Band(2)] |> plot will plot the subset without loading the whole array.\n\ngetindex on a AbstractRasterStack with a key returns another stack with getindex applied to all the arrays in the stack.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterStack","page":"Rasters.jl","title":"Rasters.RasterStack","text":"RasterStack <: AbstrackRasterStack\n\nRasterStack(data...; name, kw...)\nRasterStack(data::Union{Vector,Tuple}; name, kw...)\nRasterStack(data::NamedTuple; kw...))\nRasterStack(s::AbstractRasterStack; kw...)\nRasterStack(s::AbstractRaster; layersfrom=Band, kw...)\n\nLoad a file path or a NamedTuple of paths as a RasterStack, or convert arguments, a  Vector or NamedTuple of Raster to RasterStack.\n\nArguments\n\ndata: A NamedTuple of Raster, or a Vector, Tuple or splatted arguments   of Raster. The latter options must pass a name keyword argument.\n\nKeywords\n\nname: Used as stack layer names when a Tuple, Vector or splat of Raster is passed in.\nmetadata: A Dict or DimensionalData.Metadata object.\nrefdims: Tuple of Dimension that the stack was sliced from.\nlayersfrom: Dimension to source stack layers from if the file is not already multi-layered.   nothing is default, so that a single RasterStack(raster) is a single layered stack.   RasterStack(raster; layersfrom=Band) will use the bands as layers.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = RasterStack(files; mappedcrs=EPSG(4326))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterStack-Tuple{Type{<:RasterDataSources.RasterDataSource}}","page":"Rasters.jl","title":"Rasters.RasterStack","text":"RasterStack(T::Type{<:RasterDataSource}, [layers::Union{Symbol,AbstractArray,Tuple}]; kw...) => RasterStack\n\nLoad a RasterDataSource as an RasterStack. T and layers are passed to RasterDataSources.getraster, while kw args are for both getraster and RasterStack.\n\nKeywords\n\nmonth: an Int between 1 and 12, usually for Climate datasets.\ndate: a DateTime object, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nOther RasterStack keywords are passed to the RasterStack constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#RasterSeries","page":"Rasters.jl","title":"RasterSeries","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A series is an meta-array that holds other files/data that is distributed over some dimension, often time. These files/data can be Rasters or RasterStacks.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRasterSeries\nRasterSeries\nRasterSeries(T::Type{<:RasterDataSources.RasterDataSource})","category":"page"},{"location":"#Rasters.AbstractRasterSeries","page":"Rasters.jl","title":"Rasters.AbstractRasterSeries","text":"AbstractRasterSeries <: DimensionalData.AbstractDimensionalArray\n\nAbstract supertype for high-level DimensionalArray that hold RasterStacks, Rasters, or the paths they can be loaded from. RasterSeries are indexed with dimensions as with a AbstractRaster. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation.\n\nAs much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows syntax like for a series of stacks of arrays:\n\nRasterSeries[Time(Near(DateTime(2001, 1))][:temp][Y(Between(70, 150)), X(Between(-20,20))] |> plot`\n\nRasterSeries is the concrete implementation.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterSeries","page":"Rasters.jl","title":"Rasters.RasterSeries","text":"RasterSeries <: AbstractRasterSeries\n\nRasterSeries(arrays::AbstractArray{<:AbstractRaster}, dims; kw...)\nRasterSeries(stacks::AbstractArray{<:AbstractRasterStack}, dims; kw...)\nRasterSeries(filepaths::AbstractArray{<:AbstractString}, dims; child, duplicate_first, kw...)\nRasterSeries(dirpath:::AbstractString, dims; ext, child, duplicate_first, kw...)\n\nConcrete implementation of AbstractRasterSeries. RasterSeries are an array of Raster or RasterStack, along some dimension(s).\n\nArguments\n\ndims: series dimension/s.\n\nKeywords\n\nrefdims: existing reference dimension/s.\nchild: constructor of child objects for use with filenames are passed in,   can be Raster or RasterStack. Defaults to Raster.\nduplicate_first::Bool: wether to duplicate the dimensions and metadata of the   first file with all other files. This can save load time with a large   series where dimensions are essentially identical. true by default to improve   load times. If you need exact metadata, set to false.\next: filename extension such as \".tiff\" to find when only a directory path is passed in. \nkw: keywords passed to the child constructor Raster or RasterStack   if only file names are passed in.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterSeries-Tuple{Type{<:RasterDataSources.RasterDataSource}}","page":"Rasters.jl","title":"Rasters.RasterSeries","text":"RasterSeries(T::Type{<:RasterDataSource}, [layers::Union{Symbol,AbstractArray,Tuple}]; kw...) => AbstractRasterSeries\n\nLoad a RasterDataSource as an AbstractRasterSeries. T, args are are passed to RasterDataSource.getraster, while kw args are for both getraster and RasterSeries.\n\nKeywords\n\nmonth: a Vector or range of Int between 1 and 12, usually for Climate datasets.\ndate: a Vector of DateTime objects, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nOther RasterSeries keywords are passed to the RasterSeries constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#Dimensions","page":"Rasters.jl","title":"Dimensions","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters uses X, Y, and Z dimensions from DimensionalData.jl to represent spatial directions like longitude, latitude and the vertical dimension, and subset data with them. Ti is used for time, and Band represent bands. Other dimensions can have arbitrary names, but will be treated generically. See DimensionalData.jl for more details on how they work. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Band","category":"page"},{"location":"#Rasters.Band","page":"Rasters.jl","title":"Rasters.Band","text":"Band <: Dimension\n\nBand(val=:)\n\nBand Dimension for multi-band rasters.\n\nExample:\n\nbanddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n\n\n\n\n\n","category":"type"},{"location":"#Lookup-Arrays","page":"Rasters.jl","title":"Lookup Arrays","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These specify properties of the index associated with e.g. the X and Y dimension. Rasters.jl defines additional lookup arrays: Projected to handle dimensions with projections, and Mapped where the projection is mapped to another projection like EPSG(4326). Mapped is largely designed to handle NetCDF dimensions, especially with Explicit spans.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.AbstractProjected\nProjected\nMapped","category":"page"},{"location":"#Rasters.AbstractProjected","page":"Rasters.jl","title":"Rasters.AbstractProjected","text":"AbstractProjected <: AbstractSampled\n\nAbstract supertype for projected index lookups.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Projected","page":"Rasters.jl","title":"Rasters.Projected","text":"Projected <: AbstractProjected\n\nProjected(order, span, sampling, crs, mappedcrs)\nProjected(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs, mappedcrs=nothing)\n\nAn AbstractSampled LookupArray with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nIf both crs and mappedcrs fields contain CRS data (in a GeoFormat wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified mappedcrs projection automatically. A common use case would be to pass mappedcrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; mappedcrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf mappedcrs is not supplied (ie. mappedcrs=nothing), the base index will be shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Mapped","page":"Rasters.jl","title":"Rasters.Mapped","text":"Mapped <: AbstractProjected\n\nMapped(order, span, sampling, crs, mappedcrs)\nMapped(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs=nothing, mappedcrs)\n\nAn AbstractSampled LookupArray, where the dimension index has been mapped to another projection, usually lat/lon or EPSG(4326).\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nThe mapped dimension index will be used as for Sampled, but to save in another format the underlying projectioncrs may be used.\n\n\n\n\n\n","category":"type"},{"location":"#Data-sources","page":"Rasters.jl","title":"Data sources","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl uses a number of backends to load raster data. Raster, RasterStack and RasterSeries will detect which backend to use for you, automatically.","category":"page"},{"location":"#GRD","page":"Rasters.jl","title":"GRD","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"R GRD files can be loaded natively, using Julias MMap - which means they are very fast, but are not compressed. They are always 3 dimensional, and have Y, X and Band dimensions.","category":"page"},{"location":"#NetCDF","page":"Rasters.jl","title":"NetCDF","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"NetCDF .nc files are loaded using NCDatasets.jl. Layers from files can be loaded as Raster(\"filename.nc\"; key=:layername). Without key the first layer is used. RasterStack(\"filename.nc\") will use all netcdf variables in the file that are not dimensions as layers. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"NetCDF layers can have arbitrary dimensions. Known, common dimension names are converted to X, Y Z, and Ti, otherwise Dim{:layername} is used. Layers in the same file may also have different dimensions.","category":"page"},{"location":"#GDAL","page":"Rasters.jl","title":"GDAL","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"All files GDAL can access, such as .tiff and .asc files, can be loaded, using ArchGDAL.jl. These are generally best loaded as Raster(\"filename.tif\"), but can be loaded as RasterStack(\"filename.tif\"; layersfrom=Band), taking layers from the Band dimension, which is also the default.","category":"page"},{"location":"#SMAP","page":"Rasters.jl","title":"SMAP","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"The Soil Moisture Active-Passive dataset provides global layers of soil moisture, temperature and other related data, in a custom HDF5 format. Layers are always 2 dimensional, with Y and X dimensions.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These can be loaded as multi-layered RasterStack(\"filename.h5\"). Individual layers can be loaded as Raster(\"filename.h5\"; key=:layerkey), without key the first layer is used.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"smapseries","category":"page"},{"location":"#Rasters.smapseries","page":"Rasters.jl","title":"Rasters.smapseries","text":"smapseries(filenames::AbstractString; kw...)\nsmapseries(filenames::Vector{<:AbstractString}, dims=nothing; kw...)\n\nRasterSeries loader for SMAP files and whole folders of files, organised along the time dimension. Returns a RasterSeries.\n\nArguments\n\nfilenames: A String path to a directory of SMAP files,   or a vector of String paths to specific files.\ndims: Tuple containing Ti dimension for the series.   Automatically generated form filenames unless passed in.\n\nKeywords\n\nkw: Passed to RasterSeries.\n\n\n\n\n\n","category":"function"},{"location":"#Writing-file-formats-to-disk","page":"Rasters.jl","title":"Writing file formats to disk","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Files can be written to disk in all formats other than SMAP HDF5 using write(\"filename.ext\", A). See the docs for write. They can (with some caveats) be written to different formats than they were loaded in, providing file-type conversion for spatial data.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Some metadata may be lost in formats that store little metadata, or where metadata conversion has not been completely implemented.","category":"page"},{"location":"#RasterDataSources.jl-integration","page":"Rasters.jl","title":"RasterDataSources.jl integration","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"RasterDataSources.jl standardises the download of common raster data sources, with a focus on datasets used in ecology and the environmental sciences. RasterDataSources.jl is tightly integrated into Rasters.jl, so that datsets and keywords can be used directly to download and load data as a Raster, RasterStack, or RasterSeries.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, Plots, Dates\nA = Raster(WorldClim{Climate}, :tavg; month=June)\nplot(A)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"See the docs for Raster, RasterStack and RasterSeries, and the docs for RasterDataSources.getraster for syntax to specify various data sources.","category":"page"},{"location":"#Exported-functions","page":"Rasters.jl","title":"Exported functions","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl is a direct extension of DimensionalData.jl. See DimensionalData.jl docs for the majority of types and functions that can be used in Rasters.jl.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Functions more specific to geospatial data are included in Rasters.jl, and listed below.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"aggregate\naggregate!\nboolmask\nclassify \nclassify!\nconvertlookup\ncrop\ncrs\ndisaggregate\ndisaggregate!\nextend\nextract\ninpolygon\nmappedcrs\nmappedbounds\nmappedindex\nmask\nmask!\nmissingval\nmissingmask\nmosaic\nmosaic!\npoints\nrasterize\nrasterize!\nresample\nreplace_missing\nreproject\nsetcrs\nsetmappedcrs\nslice\nsubset\ntrim\nwarp","category":"page"},{"location":"#Rasters.aggregate","page":"Rasters.jl","title":"Rasters.aggregate","text":"aggregate(method, object, scale; filename, progress, skipmissing)\n\nAggregate a Raster, or all arrays in a RasterStack or RasterSeries, by scale using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that specifies where to sample from in the interval.\nobject: Object to aggregate, like AbstractRasterSeries, AbstractStack, AbstractRaster or Dimension.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\nWhen the aggregation scale of is larger than the array axis, the length of the axis is used.\n\nKeywords\n\nprogress: show a progress bar.\nskipmissingval: if true, any missingval will be skipped during aggregation, so that    only areas of all missing values will be aggregated to missingval. If false, any   aggegrated area containing a missingval will be assigned missingval.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nExample\n\nusing Rasters, Statistics, Plots\nusing Rasters: Center \nst = read(RasterStack(WorldClim{Climate}; month=1))\nag = aggregate(Center(), st, (Y(20), X(20)); skipmissingval=true, progress=false)\nplot(ag)\nsavefig(\"build/aggregate_example.png\") \n# output\n\n\n(Image: aggregate)\n\nNote: currently it is faster to aggregate over memory-backed arrays.  Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.aggregate!","page":"Rasters.jl","title":"Rasters.aggregate!","text":"aggregate!(method, dst::AbstractRaster, src::AbstractRaster, scale; skipmissingval=false)\n\nAggregate array src to array dst by scale, using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\nWhen the aggregation scale of is larger than the array axis, the length of the axis is used.\n\nKeywords\n\nprogress: show a progress bar.\nskipmissingval: if true, any missingval will be skipped during aggregation, so that    only areas of all missing values will be aggregated to missingval. If false, any   aggegrated area containing a missingval will be assigned missingval.\n\nNote: currently it is much faster to aggregate over memory-backed arrays.  Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.boolmask","page":"Rasters.jl","title":"Rasters.boolmask","text":"boolmask(x::AbstractArray; [missingval])\nboolmask(x; to, [order])\n\nCreate a mask array of Bool values, from any AbstractArray. An  AbstractRasterStack or AbstractRasterSeries are also accepted, but a mask is taken of the first layer or object not all of them. \n\nThe array returned from calling boolmask on a AbstractRaster is a Raster with the same size and fields as the original array.\n\nArguments\n\nx: an AbstractRaster, polygon or table.\n\nKeywords\n\nFor arrays:\n\nmissingval: The missing value of the source array. For AbstractRaster the   default missingval is missingval(A), for all other AbstractArrays it is missing.\n\nFor gemoetries:\n\nto: an AbstractRaster or AbstractRasterStack.\norder: the order of Dimensions in the points. Defaults to (XDim, YDim).\n\nExample\n\nusing Rasters, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nboolmask(wc) |> plot\n\nsavefig(\"build/boolmask_example.png\")\n# output\n\n(Image: boolmask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.classify","page":"Rasters.jl","title":"Rasters.classify","text":"classify(x, pairs; lower=(>=), upper=(<), others=nothing)\nclassify(x, pairs...; lower, upper, others)\n\nCreate a new array with values in x classified by the values in pairs.\n\npairs can hold tuples fo values (2, 3), a Fix2 function e.g. <=(1), a Tuple of Fix2 e.g. (>=(4), <(7)), or an IntervalSets.jl interval, e.g. 3..9 or OpenInterval(10, 12). pairs can also be a n * 3 matrix where each row is lower bounds, upper bounds, replacement.\n\nIf if tuples or a Matrix are used, the lower and upper keywords define how the lower and upper boundaries are chosen.\n\nIf others is set other values not covered in pairs will be set to that values.\n\nArguments\n\nx: a Raster or RasterStack\npairs: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of Fix2 like (>(x), <(y).\n\nKeywords\n\nlower: Which comparison (< or <=) to use for lower values, if Fix2 are not used.\nupper: Which comparison (> or >=) to use for upper values, if Fix2 are not used.\nothers: A value to assign to all values not included in pairs.   Passing nothing (the default) will leave them unchanged.\n\nExample\n\nusing Rasters, Plots\nA = Raster(WorldClim{Climate}, :tavg; month=1)\nclasses = <=(15) => 10,\n          15..25 => 20,\n          25..35 => 30,\n          >(35) => 40\nclassified = classify(A, classes; others=0)\nplot(classified; c=:magma)\n\nsavefig(\"build/classify_example.png\")\n# output\n\n(Image: classify)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.classify!","page":"Rasters.jl","title":"Rasters.classify!","text":"classify!(x, pairs...; lower, upper, others)\nclassify!(x, pairs; lower, upper, others)\n\nClassify the values of x in-place, by the values in pairs.\n\nIf Fix2 is not used, the lower and upper keywords\n\nIf others is set other values not covered in pairs will be set to that values.\n\nArguments\n\nx: a Raster or RasterStack\npairs: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of Fix2 like (>(x), <(y).\n\nKeywords\n\nlower: Which comparison (< or <=) to use for lower values, if Fix2 are not used.\nupper: Which comparison (> or >=) to use for upper values, if Fix2 are not used.\nothers: A value to assign to all values not included in pairs.   Passing nothing (the default) will leave them unchanged.\n\nExample\n\nclassify! to disk, with key steps:\n\ncopying a tempory file so we don't write over the RasterDataSources.jl version.\nuse open with write=true to open the file with disk-write permissions.\nuse Float32 like 10.0f0 for all our replacement values and other, because   the file is stored as Float32. Attempting to write some other type will fail.\n\nusing Rasters, Plots, RasterDataSources\n# Download and copy the file\nfilename = getraster(WorldClim{Climate}, :tavg; month=6)\ntempfile = tempname() * \".tif\"\ncp(filename, tempfile)\n# Define classes\nclasses = (5, 15) => 10,\n          (15, 25) => 20,\n          (25, 35) => 30,\n          >=(35) => 40\n# Open the file with write permission\nopen(Raster(tempfile); write=true) do A\n    classify!(A, classes; others=0)\nend\n# Open it again to plot the changes\nplot(Raster(tempfile); c=:magma)\n\nsavefig(\"build/classify_bang_example.png\")\n# output\n\n(Image: classify!)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.convertlookup","page":"Rasters.jl","title":"Rasters.convertlookup","text":"convertlookup(dstlookup::Type{<:LookupArray}, x)\n\nConvert the dimension lookup between Projected and Mapped. Other dimension lookups pass through unchanged.\n\nThis is used to e.g. save a netcdf file to GeoTiff.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.crop","page":"Rasters.jl","title":"Rasters.crop","text":"crop(x; to)\ncrop(xs...; to)\n\nCrop one or multiple AbstractRaster or AbstractRasterStack x to match the size of the object to, or smallest of any dimensions that are shared.\n\nOtherwise crop to the size of the keyword argument to. This can be a Tuple of Dimension or any object that will return one from dims(to).\n\ncrop is lazy, using a view into the object rather than alocating new memory.\n\nKeywords\n\nto: the object to crop to. If to keyword is passed, the smallest shared   area of all xs is used.\n\nAs crop is lazy, filename and suffix keywords don't apply.\n\nExample\n\nCropt to another raster:\n\nusing Rasters, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out New Zealand from the evenness raster\nnz_bounds = X(Between(165, 180)), Y(Between(-32, -50))\nnz_evenness = evenness[nz_bounds...]\n\n# Crop range to match evenness\nnz_range = crop(rnge; to=nz_evenness)\nplot(nz_range)\n\nsavefig(\"build/crop_example.png\")\n# output\n\n![new zealand evennes cropped]/nzcropexample.png)\n\nCrop to a polygon:\n\nusing Rasters, Plots, Dates, Shapefile, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\nshp = Shapefile.Handle(shapefile_name).shapes[6]\nargentina_range = crop(evenness; to=shp)\nplot(argentina_range)\nsavefig(\"build/argentina_crop_example.png\")\n\n![argentina evenness cropped]/argentinacropexample.png)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.crs","page":"Rasters.jl","title":"Rasters.crs","text":"crs(x)\n\nGet the projected coordinate reference system of a Y or X Dimension, or of the Y/X dims of an AbstractRaster.\n\nFor Mapped lookup this may be nothing as there may be no projected coordinate reference system at all.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.disaggregate","page":"Rasters.jl","title":"Rasters.disaggregate","text":"disaggregate(method, object, scale; filename, progress, keys)\n\nDisaggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractRasterSeries, AbstractStack, AbstractRaster or a Dimension.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\nKeywords\n\nprogress: show a progress bar.\n\nNote: currently it is faster to aggregate over memory-backed arrays.  Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.disaggregate!","page":"Rasters.jl","title":"Rasters.disaggregate!","text":"disaggregate!(method, dst::AbstractRaster, src::AbstractRaster, filename, scale)\n\nDisaggregate array src to array dst by some scale, using method.\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\nNote: currently it is faster to aggregate over memory-backed arrays.  Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.extend","page":"Rasters.jl","title":"Rasters.extend","text":"extend(xs...; [to])\nextend(xs; [to])\nextend(x::Union{AbstractRaster,AbstractRasterStack}; to, kw...)\n\nExtend one or multiple AbstractRaster to match the area covered by all xs, or by the keyword argument to.\n\nKeywords\n\nto: the Raster or dims to extend to. If no to keyword is passed, the largest   shared area of all xs is used.\natol: the absolute tolerance value to use when comparing the index of x and to.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nusing Rasters, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out South America\nsa_bounds = X(Between(-88, -32)), Y(Between(-57, 13))\nsa_evenness = evenness[sa_bounds...]\n\n# Extend range to match the whole-world raster\nsa_range = extend(sa_evenness; to=rnge)\nplot(sa_range)\n\nsavefig(\"build/extend_example.png\")\n# output\n\n(Image: extend)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.extract","page":"Rasters.jl","title":"Rasters.extract","text":"extract(x, points; order, atol)\n\nExtracts the value of Raster or RasterStack at given points, returning a vector of NamedTuple with columns for the point dimensions and layer value/s.\n\nNote that if objects have more dimensions than the length of the point tuples, sliced arrays or stacks will be returned instead of single values.\n\nArguments\n\nx: a Raster or RasterStack to extract values from.\npoints: multiple Vectors of point values, a Vector{Tuple},   or a single Tuple or Vector. points can also be a Tables.jl compatible   table, in which case order may need to specify the keys.\n\nKeywords\n\norder: a tuple of Dimension connecting the order of the points to the array   axes, such as (X, Y), with a defaut (XDim, YDim, ZDim) order.   If points is a table, order should be a Tuple of Dimension/Symbol pairs   like (X => :xcol, Y => :ycol). This will be automatically detected wherever   possible, assuming the keys match the dimensions of the object x.\natol: a tolorerance for floating point lookup values for when the LookupArray   contains Points. atol is ignored for Intervals.\n\nNote: extracting polygons in a GeoInterface.AbstractGeometry is not yet supported, but will be in future.\n\nExample\n\nHere we extact points matching the occurrence of the Mountain Pygmy Possum, Burramis parvus. This could be used to fit a species distribution lookupl.\n\nusing Rasters, GBIF, CSV\n\n# Get a stack of BioClim layers, and replace missing values with `missing`\nst = RasterStack(WorldClim{BioClim}, (1, 3, 5, 7, 12))[Band(1)] |> replace_missing\n\n# Download some occurrence data\nobs = GBIF.occurrences(\"scientificName\" => \"Burramys parvus\", \"limit\" => 5)\n\n# use `extract` to get values for all layers at each observation point.\npoints = map(o -> (o.longitude, o.latitude), obs)\nvals = extract(st, points)\n\n# output\n5-element Vector{NamedTuple{(:X, :Y, :bio1, :bio3, :bio5, :bio7, :bio12)}}:\n (X = missing, Y = missing, bio1 = missing, bio3 = missing, bio5 = missing, bio7 = missing, bio12 = missing)\n (X = 147.096394, Y = -36.935687, bio1 = 9.408354f0, bio3 = 40.790546f0, bio5 = 22.39425f0, bio7 = 23.0895f0, bio12 = 1292.0f0)\n (X = 148.450743, Y = -35.999643, bio1 = 8.269542f0, bio3 = 41.030262f0, bio5 = 21.4485f0, bio7 = 23.858f0, bio12 = 1440.0f0)\n (X = 148.461854, Y = -36.009001, bio1 = 6.928167f0, bio3 = 41.78015f0, bio5 = 20.18025f0, bio7 = 23.69975f0, bio12 = 1647.0f0)\n (X = 148.459452, Y = -36.002648, bio1 = 6.928167f0, bio3 = 41.78015f0, bio5 = 20.18025f0, bio7 = 23.69975f0, bio12 = 1647.0f0)\n\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.inpolygon","page":"Rasters.jl","title":"Rasters.inpolygon","text":"inpolygon(points, poly)\n\nCheck if a point or points are inside a polygon.\n\nThis algorithm is very efficient for many points, less so a single point.\n\nArguments\n\npoints: an AbstractVector or a Tuple or Real, an AbstractVector of these,   or a GeoInterface.AbstractGeometry.\npoly: an AbstractVector or nested AbstractVector with an inner   AbstractVector or Tuple of Real, or a GeoInterface.AbstractPolygon.\n\nReturns a Bool or AbstractVector{Bool}.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedcrs","page":"Rasters.jl","title":"Rasters.mappedcrs","text":"mappedcrs(x)\n\nGet the mapped coordinate reference system for the Y/X dims of an array.\n\nIn Projected lookup this is used to convert Selector values form the mappedcrs defined projection to the underlying projection, and to show plot axes in the mapped projection.\n\nIn Mapped lookup this is the coordinate reference system of the index values.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedbounds","page":"Rasters.jl","title":"Rasters.mappedbounds","text":"mappedbounds(x)\n\nGet the bounds converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular bounds.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedindex","page":"Rasters.jl","title":"Rasters.mappedindex","text":"mappedindex(x)\n\nGet the index value of a dimension converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular dim value.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mask","page":"Rasters.jl","title":"Rasters.mask","text":"mask(A:AbstractRaster; with, missingval=missingval(A))\nmask(x; with, order=(XDim, YDim))\n\nReturn a new array with values of A masked by the missing values of with, or by the shape of with, if with is a geometric object.\n\nArguments\n\nx: a Raster or RasterStack\n\nKeywords\n\nwith: another AbstractRaster, a AbstractVector of Tuple points,   or any GeoInterface.jl AbstractGeometry. The coordinate reference system   of the point must match crs(A).\norder: the order of Dimensions in the points. Defaults to (XDim, YDim).\nmissingval: the missing value to use in the returned file.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nGeometry keywords\n\nThese can be used when a GeoInterface.AbstractGeometry is passed in.\n\nshape: Force data to be treated as :polygon, :line or :point.   With GeoInterface.jl geometries this will be detected from the data.\n\nAnd specifically for shape=:polygon:\n\nboundary: include pixels where the :center is inside the polygon, where    the line :touches the pixel, or that are completely :inside inside the polygon.\n\nExample\n\nMask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask.\n\nusing Rasters, Plots, Dates\n\n# Load and plot the file\nawap = read(Raster(AWAP, :tmax; date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45))\n\n# Create a mask my resampling a worldclim file\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask\nawap_masked = mask(awap; with=wc_mask)\nb = plot(awap_masked; clims=(10, 45))\n\nsavefig(a, \"build/mask_example_before.png\")\nsavefig(b, \"build/mask_example_after.png\")\n# output\n\n\nBefore mask:\n\n(Image: before mask)\n\nAfter mask:\n\n(Image: after mask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mask!","page":"Rasters.jl","title":"Rasters.mask!","text":"mask!(x; with, missingval=missingval(A), order=(XDim, YDim))\n\nMask A by the missing values of with, or by all values outside with if it is a polygon.\n\nIf with is a polygon, creates a new array where points falling outside the polygon have been replaced by missingval(A).\n\nReturn a new array with values of A masked by the missing values of with, or by a polygon.\n\nArguments\n\nx: a Raster or RasterStack.\n\nKeywords\n\nwith: another AbstractRaster, a AbstractVector of Tuple points,   or any GeoInterface.jl AbstractGeometry. The coordinate reference system   of the point must match crs(A).\norder: the order of Dimensions in the points. Defaults to (XDim, YDim).\nmissingval: the missing value to write to A in masked areas,   by default missingval(A).\n\nExample\n\nMask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask to match the size and projection.\n\nusing Rasters, Plots, Dates\n\n# Load and plot the file\nawap = read(RasterStack(AWAP, (:tmin, :tmax); date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45))\n\n# Create a mask my resampling a worldclim file \nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask \nmask!(awap; with=wc_mask) \nb = plot(awap; clims=(10, 45))\n\nsavefig(a, \"build/mask_bang_example_before.png\")\nsavefig(b, \"build/mask_bang_example_after.png\")\n# output\n\nBefore mask!:\n\n(Image: before mask!)\n\nAfter mask!:\n\n(Image: after mask!)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.missingval","page":"Rasters.jl","title":"Rasters.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.missingmask","page":"Rasters.jl","title":"Rasters.missingmask","text":"missingmask(x; kw...)\n\nCreate a mask array of missing or true values, from any AbstractArray. For AbstractRaster the default missingval is missingval(A), for all other AbstractArrays it is missing.\n\nThe array returned from calling missingmask on a AbstractRaster is a Raster with the same size and fields as the original array.\n\nExample\n\nusing Rasters, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nmissingmask(wc) |> plot\n\nsavefig(\"build/missingmask_example.png\")\n# output\n\n(Image: missingmask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mosaic","page":"Rasters.jl","title":"Rasters.mosaic","text":"mosaic(f, regions...; missingval, atol)\nmosaic(f, regions; missingval, atol)\n\nCombine regionss into a single raster.\n\nArguments\n\nf: A reducing function (e.g. mean, sum, first or last) for values where regions overlap.\nregions: Iterable or splatted Raster or RasterStack.\n\nKeywords\n\nmissingval: Fills empty areas, and defualts to the   missingval of the first layer.\natol: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.\nfilename: a file to write to directly.\n\nIf your mosaic has has apparent line errors, increase the atol value.\n\nExample\n\nHere we cut out australia and africa from a stack, and join them with mosaic.\n\nusing Rasters, Plots\nst = RasterStack(WorldClim{Climate}; month=1);\n\nafrica = st[X(Between(-20.0, 60.0)), Y(Between(35.0, -40.0))]\na = plot(africa)\n\naus = st[X(Between(100.0, 160.0)), Y(Between(-10.0, -50.0))]\nb = plot(aus)\n\n# Combine with mosaic\nmos = mosaic(first, aus, africa)\nc = plot(mos)\n\nsavefig(a, \"build/mosaic_example_africa.png\")\nsavefig(b, \"build/mosaic_example_aus.png\")\nsavefig(c, \"build/mosaic_example_combined.png\")\n# output\n\n\nIndividual continents\n\n(Image: arica)\n\n(Image: aus)\n\nMosaic of continents\n\n(Image: mosaic)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mosaic!","page":"Rasters.jl","title":"Rasters.mosaic!","text":"mosaic!(f, x, regions...; missingval, atol)\nmosaic!(f, x, regions::Tuple; missingval, atol)\n\nCombine regionss in x using the function f.\n\nArguments\n\nf a function (e.g. mean, sum, first or last) that is applied to   values where regions overlap.\nx: A Raster or RasterStack. May be a an opened disk-based Raster,   the result will be written to disk.   slow read speed with the current algorithm\nregions: source objects to be joined. These should be memory-backed   (use read first), or may experience poor performance. If all objects have   the same extent, mosaic is simply a merge.\n\nKeywords\n\nmissingval: Fills empty areas, and defualts to the `missingval/   of the first layer.\natol: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.\n\nExample\n\nCut out Australia and Africa stacks, then combined them into a single stack.\n\nusing Rasters, Statistics, Plots\nst = read(RasterStack(WorldClim{Climate}; month=1))\naus = st[X(Between(100.0, 160.0)), Y(Between(-10.0, -50.0))]\nafrica = st[X(Between(-20.0, 60.0)), Y(Between(35.0, -40.0))]\nmosaic!(first, st, aus, africa)\nplot(st)\nsavefig(\"build/mosaic_bang_example.png\")\n# output\n\n\n(Image: mosaic)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.points","page":"Rasters.jl","title":"Rasters.points","text":"points(A::AbstractRaster; dims=(YDim, XDim), ignore_missing) => Array{Tuple}\n\nReturns a generator of the points in A for dimensions in dims, where points are a tuple of the values in each specified dimension index.\n\nKeywords\n\ndims the dimensions to return points from. The first slice of other   layers will be used.\nignore_missing: wether to ignore missing values in the array when considering   points. If true, all points in the dimensions will be returned, if false   only the points that are not === missingval(A) will be returned.\n\nThe order of dims determines the order of the points.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.rasterize","page":"Rasters.jl","title":"Rasters.rasterize","text":"rasterize(x; kw...)\nrasterize(points, values; kw...)\n\nRasterize the points and values in a Tables.jl compatible object, or separate points and values vetors/iterators, which must be the same length.\n\nIf a GeoInterface AbstractGeometry or nested Vectors of Tuple/Vector points is passed in, a fill keyword is also required to provide the value that the array will be filled with. If fill is a function, it will be applied to the existing value present in the array.\n\nArguments\n\nx: a Tables.jl compatible object containing points and values columns,   an GeoInterface.jl AbstractGeometry, or a nested Vector of Vectors.\npoints: A Vector or nested Vectors holding Vector or Tuple of Real\nvalues A Vector of values to be written to a Raster, or a Vector of NamedTuple   to write to a RasterStack.\n\nKeywords\n\nThese are detected automatically from A and data where possible.\n\nto: a Raster, RasterStack of Tuple of Dimension to use as a to.\norder: A Tuple of pairs Dim => Symbol for the keys in the data that match   the dimension, or for the order of dimensions in ppoint values, like (X, Y).\natol: an absolute tolerance for rasterizing to dimensions with Points sampling.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nGeometry keywords\n\nThese can be used when a GeoInterface.AbstractGeometry is passed in.\n\nfill: the value to fill a polygon with, if data is a polygon. \nshape: Force data to be treated as :polygon, :line or :point.\n\nAnd specifically for shape=:polygon:\n\nboundary: include pixels where the :center is inside the polygon, where    the line :touches the pixel, or that are completely :inside inside the polygon.\n\nTable keywords\n\nname: A Symbol to return a Raster from a single column,   or Tuple of Symbol to return a RasterStack from multiple columns.\n\nExample\n\nRasterize a shapefile for China and plot, with a border.\n\nusing Rasters, Plots, Dates, Shapefile, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary_lines.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Loade the shapes for china\nchina_border = Shapefile.Handle(shapefile_name).shapes[10]\n\n# Define dims for the china area\ndms = Y(Projected(15.0:0.1:55.0; order=ForwardOrdered(), span=Regular(0.1), sampling=Intervals(Start()), crs=EPSG(4326))), \n      X(Projected(70.0:0.1:140; order=ForwardOrdered(), span=Regular(0.1), sampling=Intervals(Start()), crs=EPSG(4326)))\n\n# Rasterize the border polygon \nchina = rasterize(china_border; \n    to=dms, missingval=-9999, fill=1, \n    order=(X, Y), shape=:polygon, \n    boundary=:touches,\n)\n\n# And plot\np = plot(china; color=:spring)\nplot!(p, china_border; fillalpha=0, linewidth=0.6)\nsavefig(\"build/china_rasterized.png\")\n\n# output\n\n(Image: rasterize)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.rasterize!","page":"Rasters.jl","title":"Rasters.rasterize!","text":"rasterize!(x, data; order, name, atol)\nrasterize!(x, points, vals; order, atol)\n\nRasterize the points and vals in data, or the points and vals objects, into the Raster or RasterStack x.\n\nArguments\n\nx: a Raster or RasterStack to rasterize to.\ndata: a Tables.jl compatible object containing points and values or a   polygon - an GeoInterface.jl AbstractGeometry, or a nested Vector of Vectors.\npoints: A Vector or nested Vector holding Vector or Tuple of Real\nvals A Vector of values to be written when x is a Raster, or a Vector of   NamedTuple to write when x is a RasterStack.\n\nKeywords\n\nThese are detected automatically from A and data where possible.\n\norder: A Tuple of pairs Dim => Symbol for the keys in the data that match   the dimension, or for the order of dimensions in points, like (X, Y).\natol: an absolute tolerance for rasterizing to dimensions with Points sampling.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nGeometry keywords\n\nThese can be used when a GeoInterface.AbstractGeometry is passed in.\n\nfill: the value to fill a polygon with, if data is a polygon.   fill can also be aFunction` of the existing value.\nshape: Force data to be treated as :polygon, :line or :point.\n\nAnd specifically for shape=:polygon:\n\nboundary: include pixels where the :center is inside the polygon, where    the line :touches the pixel, or that are completely :inside inside the polygon.\n\nTable keywords\n\nname: A Symbol to return a Raster from a single column,   or Tuple of Symbol to return a RasterStack from multiple columns.\n\nExample\n\nusing Rasters, Plots, Dates, Shapefile, GeoInterface, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"indonesia_border.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Load the shapes for denmark\nindonesia_border = Shapefile.Handle(shapefile_name).shapes[1]\n\n# Make an empty EPSG 4326 projected Raster of the area of Indonesia\ndimz = Y(-15.0:0.1:10.9; mode=Projected(; sampling=Intervals(Start()), crs=EPSG(4326))), \n       X(90.0:0.1:145; mode=Projected(; sampling=Intervals(Start()), crs=EPSG(4326)))\n\nA = Raster(zeros(UInt16, dimz); missingval=0)\n\n# Rasterize each island with a different number\nfor (i, shp) in enumerate(coordinates(indonesia_border))\n    rasterize!(A, shp; fill=i, order=(X, Y), shape=:polygon, boundary=:touches)\nend\n\n# And plot\np = plot(A; color=:spring)\nplot!(p, indonesia_border; fillalpha=0, linewidth=0.7)\nsavefig(\"build/indonesia_rasterized.png\")\n\n# output\n\n\n(Image: rasterize)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.resample","page":"Rasters.jl","title":"Rasters.resample","text":"resample(x, resolution::Number; crs, method)\nresample(x; to, method)\nresample(xs...; to=first(xs), method)\n\nresample uses ArchGDAL.gdalwarp to resample a Raster or RasterStack to a new resolution and optionally new crs, or to snap to the bounds, resolution and crs of the object to.\n\nArguments\n\nx: the object to resample.\nresolution: a Number specifying the resolution for the output.   If the keyword argument crs (described below) is specified, resolution must be in units of the crs.\n\nKeywords\n\nto: an AbstractRaster whos resolution, crs and bounds will be snapped to.   For best results it should roughly cover the same extent, or a subset of A.\ncrs: A GeoFormatTypes.GeoFormat such as EPSG(x) or WellKnownText(string) specifying an   output crs (A will be reprojected to crs in addition to being resampled). Defaults to crs(A)\nmethod: A Symbol or String specifying the method to use for resampling.   From the docs for gdalwarp:\n:near: nearest neighbour resampling (default, fastest algorithm, worst interpolation quality).\n:bilinear: bilinear resampling.\n:cubic: cubic resampling.\n:cubicspline: cubic spline resampling.\n:lanczos: Lanczos windowed sinc resampling.\n:average: average resampling, computes the weighted average of all non-NODATA contributing pixels.   rms root mean square / quadratic mean of all non-NODATA contributing pixels (GDAL >= 3.3)\n:mode: mode resampling, selects the value which appears most often of all the sampled points.\n:max: maximum resampling, selects the maximum value from all non-NODATA contributing pixels.\n:min: minimum resampling, selects the minimum value from all non-NODATA contributing pixels.\n:med: median resampling, selects the median value of all non-NODATA contributing pixels.\n:q1: first quartile resampling, selects the first quartile value of all non-NODATA contributing pixels.\n:q3: third quartile resampling, selects the third quartile value of all non-NODATA contributing pixels.\n:sum: compute the weighted sum of all non-NODATA contributing pixels (since GDAL 3.1)\nWhere NODATA values are set to missingval.\n\nNote: missingval of missing does not work with GDAL. Use replace_missing(A, newmissingval) to  assign a missing value before using resample if the current value is missing. This will be  automated in future versions.\n\nExample\n\nResample a WorldClim layer to match an EarthEnv layer:\n\nusing Rasters, Plots\nA = Raster(WorldClim{Climate}, :prec; month=1)\nB = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\n\na = plot(A)\nb = plot(resample(A; to=B))\n\nsavefig(a, \"build/resample_example_before.png\")\nsavefig(b, \"build/resample_example_after.png\")\n# output\n\nBefore resample:\n\n(Image: before resample)\n\nAfter resample:\n\n(Image: after resample)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.replace_missing","page":"Rasters.jl","title":"Rasters.replace_missing","text":"replace_missing(a::AbstractRaster, newmissingval)\nreplace_missing(a::AbstractRasterStack, newmissingval)\n\nReplace missing values in the array or stack with a new missing value, also updating the missingval field/s.\n\nKeywords\n\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(st) are the default.\n\nExample\n\nusing Rasters\nA = Raster(WorldClim{Climate}, :prec; month=1) |> replace_missing\nmissingval(A)\n# output\nmissing\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.reproject","page":"Rasters.jl","title":"Rasters.reproject","text":"reproject(source::GeoFormat, target::GeoFormat, dim::Dimension, val)\n\nreproject uses ArchGDAL.reproject, but implemented for a reprojecting a value array of values, a single dimension at a time.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.setcrs","page":"Rasters.jl","title":"Rasters.setcrs","text":"setcrs(x, crs)\n\nSet the crs of a Raster, RasterStack, Tuple of Dimension,or a Dimension.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.setmappedcrs","page":"Rasters.jl","title":"Rasters.setmappedcrs","text":"setmappedcrs(x, crs)\n\nSet the mapped crs of a Raster, a RasterStack, a Tuple of Dimension, or a Dimension.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.slice","page":"Rasters.jl","title":"Rasters.slice","text":"slice(A::Union{AbstractRaster,AbstractRasterStack,AbstracRasterSeries}, dims) => RasterSeries\n\nSlice an object along some dimension/s, lazily using view.\n\nFor a single Raster or RasterStack this will return a RasterSeries of Raster or RasterStack that are slices along the specified dimensions.\n\nFor a RasterSeries, the output is another series where the child objects are sliced and the series dimensions index is now of the child dimensions combined. slice on a RasterSeries with no dimensions will slice along the dimensions shared by both the series and child object.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.subset","page":"Rasters.jl","title":"Rasters.subset","text":"subset(s::AbstractRasterStack, keys)\n\nSubset a stack to hold only the layers in keys, where keys is a Tuple or Array of String or Symbol, or a Tuple or Array of Int\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.trim","page":"Rasters.jl","title":"Rasters.trim","text":"trim(x; dims::Tuple, pad::Int)\n\nTrim missingval(x) from x for axes in dims, returning a view of x.\n\nArguments\n\nx: A Raster or RasterStack. For stacks, all layers must having   missing values for a pixel for it to be trimmed.\n\nKeywords\n\ndims: By default dims=(XDim, YDim), so that trimming keeps the area    of X and Y that contains non-missing values along all other dimensions.\npad: The trimmed size will be padded by pad on all sides, although   padding will not be added beyond the original extent of the array.\n\ntrim does not accept filename/suffix arguments as it does not alter the underlying data.\n\nExample\n\nCreate trimmed layers of Australian habitat heterogeneity.\n\nusing Rasters, Plots\nlayers = (:evenness, :range, :contrast, :correlation)\nst = RasterStack(EarthEnv{HabitatHeterogeneity}, layers)\nplot(st)\n\n# Roughly cut out australia\nausbounds = X(Between(100, 160)), Y(Between(-10, -50))\naus = st[ausbounds...]\na = plot(aus)\n\n# Trim missing values and plot\nb = plot(trim(aus))\n\nsavefig(a, \"build/trim_example_before.png\")\nsavefig(b, \"build/trim_example_after.png\")\n# output\n\nBefore trim:\n\n(Image: before trim)\n\nAfter trim:\n\n(Image: after trim)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.warp","page":"Rasters.jl","title":"Rasters.warp","text":"warp(A::AbstractRaster, flags::Dict)\n\nGives access to the GDALs gdalwarp method given a Dict of flags, where arguments than can be converted to strings, or vectors of such arguments for flags that take multiple space-separated arguments.\n\nArrays with additional dimensions not handled by GDAL (ie other than X, Y, Band) are sliced, warped, and then combined - these dimensions will not change.\n\nSee the gdalwarp docs for a list of arguments.\n\nExample\n\nThis simply resamples the array with the :tr (output file resolution) and :r flags, giving us a pixelated version:\n\nusing Rasters, RasterDataSources, Plots\nA = Raster(WorldClim{Climate}, :prec; month=1)\nplot(A)\nsavefig(\"build/warp_example_before.png\")\nflags = Dict(\n    :tr => [2.0, 2.0],\n    :r => :near,\n)\nwarp(A, flags) |> plot\n\nsavefig(\"build/warp_example_after.png\")\n# output\n\nBefore warp:\n\n(Image: before warp)\n\nAfter warp:\n\n(Image: after warp)\n\nIn practise, prefer resample for this. But warp may be more flexible.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#File-operations","page":"Rasters.jl","title":"File operations","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These Base and DimensionalData methods have specific Rasters.jl versions:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"modify\nopen\nread\nread!\nwrite","category":"page"},{"location":"#DimensionalData.modify","page":"Rasters.jl","title":"DimensionalData.modify","text":"modify(f, series::AbstractRasterSeries)\n\nApply function f to the data of the child object. If the child is an AbstractRasterStack the function will be passed on to its child AbstractRasters.\n\nf must return an idenically sized array.\n\nThis method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.\n\nThis is useful for swapping out array backend for an entire series to CuArray from CUDA.jl to copy data to a GPU, and potentially other types like DAarray from Distributed.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Base.open","page":"Rasters.jl","title":"Base.open","text":"open(f, A::AbstractRaster; write=false)\n\nopen is used to open any AbstractRaster and do multiple operations on it in a safe way. The write keyword opens the file in write lookup so that it can be altered on disk using e.g. a broadcast.\n\nf is a method that accepts a single argument - an Raster object which is just an AbstractRaster that holds an open disk-based object. Often it will be a do block:\n\n# A is an `Raster` wrapping the opened disk-based object.\nopen(Raster(filepath); write=true) do A\n    mask!(A; to=maskfile)\n    A[I...] .*= 2\n    # ...  other things you need to do with the open file\nend\n\nBy using a do block to open files we ensure they are always closed again after we finish working with them.\n\n\n\n\n\n","category":"function"},{"location":"#Base.read","page":"Rasters.jl","title":"Base.read","text":"read(A::AbstractRaster)\nread(A::AbstractRasterStack)\nread(A::AbstractRasterSeries)\n\nread will move a Rasters.jl object completely to memory.\n\n\n\n\n\n","category":"function"},{"location":"#Base.read!","page":"Rasters.jl","title":"Base.read!","text":"read!(src::Union{AbstractString,AbstractRaster}, dst::AbstractRaster)\nread!(src::Union{AbstractString,AbstractRasterStack}, dst::AbstractRasterStack)\nread!(scr::AbstractRasterSeries, dst::AbstractRasterSeries)\n\nread! will copy the data from src to the object dst. \n\nsrc can be an object or a file-path String.\n\n\n\n\n\n","category":"function"},{"location":"#Base.write","page":"Rasters.jl","title":"Base.write","text":"Base.write(filename::AbstractString, A::AbstractRaster; kw...)\n\nWrite an AbstractRaster to file, guessing the backend from the file extension.\n\nKeyword arguments are passed to the write method for the backend.\n\n\n\n\n\nBase.write(filename::AbstractString, s::AbstractRasterStack; suffix, kw...)\n\nWrite any AbstractRasterStack to file, guessing the backend from the file extension.\n\nKeywords\n\nsuffix: suffix to append to file names. By default the layer key is used. \n\nOther keyword arguments are passed to the write method for the backend.\n\nIf the source can't be saved as a stack-like object, individual array layers will be saved.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GRDfile}, s::AbstractRaster)\n\nWrite a Raster to a .grd file with a .gri header file.  The extension of filename will be ignored.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDfile}, s::AbstractRaster)\n\nWrite an NCDarray to a NetCDF file using NCDatasets.jl\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDfile}, s::AbstractRasterStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently Metadata is not handled for dimensions, and Metadata from other AbstractRaster @types is ignored.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GDALfile}, A::AbstractRaster; kw...)\n\nWrite a Raster to file using GDAL.\n\nKeywords\n\ndriver::String: a GDAL driver name. Guessed from the filename extension by default.\ncompress::String: GeoTIFF compression flag. \"DEFLATE\" by default.\ntiled::Bool: GeoTiff tiling. Defaults to true.\n\nReturns filename.\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Rasters.jl","title":"Internals","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.FileArray\nRasters.FileStack\nRasters.RasterDiskArray","category":"page"},{"location":"#Rasters.FileArray","page":"Rasters.jl","title":"Rasters.FileArray","text":"FileArray{X} <: DiskArrays.AbstractDiskArray\n\nFilearray is a DiskArrays.jl AbstractDiskArray. Instead of holding an open object, it just holds a filename string that is opened lazily  when it needs to be read.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.FileStack","page":"Rasters.jl","title":"Rasters.FileStack","text":"FileStack{X,K}\n\nFileStack{X,K}(filename, types, sizes, eachchunk, haschunks, write)\n\nA wrapper object that holds file pointer and size/chunking metadata for a multi-layered stack stored in a single file,  typically netcdf or hdf5.\n\nX is a backend singleton like GDALfile, and K is a tuple of Symbol keys.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterDiskArray","page":"Rasters.jl","title":"Rasters.RasterDiskArray","text":"RasterDiskArray <: DiskArrays.AbstractDiskArray\n\nA basic DiskArrays.jl wrapper for objects that don't have one defined yet.  When we open a FileArray it is replaced with a RasterDiskArray.\n\n\n\n\n\n","category":"type"}]
}
