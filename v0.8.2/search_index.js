var documenterSearchIndex = {"docs":
[{"location":"#Rasters.jl","page":"Rasters.jl","title":"Rasters.jl","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters","category":"page"},{"location":"#Rasters","page":"Rasters.jl","title":"Rasters","text":"Rasters\n\n(Image: ) (Image: ) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nRasters.jl defines common types and methods for reading, writing and manipulating rasterized spatial data. \n\nThese currently include raster arrays like GeoTIFF and NetCDF, R grd files,  multi-layered stacks, and multi-file series of arrays and stacks. \n\n(Image: EarthEnv HabitatHeterogeneity layers trimmed to Australia)\n\nA RasterStack of EarthEnv HabitatHeterogeneity layers, trimmed to Australia and plotted with Plots.jl\n\n:warning: Packages extensions and Rasters 0.8 and onwards\n\nOn Julia 1.9 we can put additional packages in extensions, so the code only loads when you load a specific package. Rasters.jl was always intended to work like this, and its finally possible. This reduced package using time from many seconds to well under a second.\n\nBut, it means you have to manually load packages you need for each backend or additional functionality.\n\nFor example, to use the GDAL backend, and download files, you now need to do:\n\nusing Rasters, ArchGDAL, RasterDataSources\n\nwhere previously it was just using Rasters.\n\nSources and packages needed:\n\n:gdal: using ArchGDAL\n:netcdf: using NCDatasets\n:grd: built-in.\n:smap: using HDF5\n:grib: not yet finished.\n\nOther functionality in extensions:\n\nRaster data downloads, like Worldclim{Climate}: using RasterDataSources\nMakie plots: using Makie\nCoordinate transformations for gdal rasters: using CoordinateTransformations\n\nQuick start\n\nInstall the package by typing:\n\n]\nadd Rasters\n\nusing Rasters\n\nUsing Rasters to read GeoTiff or NetCDF files will output something similar to the following toy examples. This is possible because Rasters.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like X, Y and Ti (time) and e.g. spatial coordinates.\n\nusing Rasters, Dates\nlon, lat = X(25:1:30), Y(25:1:30)\nti = Ti(DateTime(2001):Month(1):DateTime(2002))\nras = Raster(rand(lon, lat, ti)) # this generates random numbers with the dimensions given\n\n6×6×13 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2002-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")))\nmissingval: missing\nvalues: [:, :, 1]\n     25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n[and 12 more slices...]\n\nGetting the lookup array from dimensions\n\nlon = lookup(ras, X) # if X is longitude\nlat = lookup(ras, Y) # if Y is latitude\n\nSampled{Int64} ForwardOrdered Regular Points\nwrapping: 25:1:30\n\nSelect by index\n\nSelecting a time slice by index is done via\n\nras[Ti(1)]\n\n6×6 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n\nras[Ti=1]\n\n6×6 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n\nor and interval of indices using the syntax =a:b or (a:b)\n\nras[Ti(1:10)]\n\n6×6×10 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-10-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2001-10-01T00:00:00\")))\nmissingval: missing\nvalues: [:, :, 1]\n     25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n[and 9 more slices...]\n\nSelect by value\n\nras[Ti=At(DateTime(2001))]\n\n6×6 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n\nMore options are available, like  Near, Contains and Where. For more details go here.\n\nDimensions can also be used in most Base and Statistics methods like mean and reduce where dims arguments are required. Much of the behaviour is covered in the DimensionalData docs.\n\nSee the docs for more details and examples for Rasters.jl.\n\nData-source abstraction\n\nRasters provides a standardised interface that allows many source data types to be used with identical syntax.\n\nScripts and packages building on Rasters.jl can treat Raster, RasterStack, and RasterSeries as black boxes.\nThe data could hold GeoTiff or NetCDF files, Arrays in memory or CuArrays on the GPU - they will all behave in the same way.\nRasterStack can be backed by a Netcdf or HDF5 file, or a NamedTuple of Raster holding .tif files, or all Raster in memory.\nUsers do not have to deal with the specifics of spatial file types.\nProjected lookups with Cylindrical projections can by indexed using other Cylindrical projections by setting the mappedcrs keyword on construction. You don't need to know the underlying projection, the conversion is handled automatically. This means lat/lon EPSG(4326) can be used seamlessly if you need that.\n\nBugs, errors and making issues for Rasters.jl\n\nRaster data is complicated and there are many places for subtle or not-so-subtle bugs to creep in.\n\nWe need bug reports to reduce how often they occur over time. But also, we need issues that are easy to reproduce or it isn't practically possible to fix them.\n\nBecause there are so many raster file types and variations of them, most of the time we need the exact file that caused your problem to know how to fix it, and be sure that we have actually fixed it when we are done. So fixing a Rasters.jl bug nearly always involves downloading some file and running some code that breaks with it (if you can trigger the bug without a file, thats great! but its not always possible).\n\nTo make an issue we can fix quickly (or at all) there are three key steps:\n\nInclude the file in an accessible place on web without autentication or any other work on our part, so we can just get it and find your bug. You can put it on a file hosting platform (e.g. google drive, drop box, whatever you use) and share the url.\nAdd a minimum working example to the issue template that first downloads the file, then runs the function that triggers the bug.\nPaste the complete stack trace of the error it produces, right to the bottom, into the issue template. Then we can be sure we reproduced the same problem.\n\nGood issues are really appreciated, but they do take just a little extra effort with Rasters.jl because of this need for files.\n\n\n\n\n\n","category":"module"},{"location":"#Common-Applications","page":"Rasters.jl","title":"Common Applications","text":"","category":"section"},{"location":"#Subsetting-an-object","page":"Rasters.jl","title":"Subsetting an object","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Regular getindex (e.g. A[1:100, :]) and view work on all objects just as with an Array. view is always lazy, and reads from disk are deferred until getindex is used. DimensionalData.jl Dimensions and Selectors are the other way to subset an object, making use of the objects index to find values at  e.g. certain X/Y coordinates. The available selectors are listed here:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nAt(x) get the index exactly matching the passed in value(s).\nNear(x) get the closest index to the passed in value(s).\nWhere(f::Function) filter the array axis by a function of the dimension index values.\na..b/Between(a, b) get all indices between two values, excluding the high value.\nContains(x) get indices where the value x falls within an interval.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Use the .. selector to take a view of madagascar:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{BioClim}, 5)\nmadagascar = view(A, X(43.25 .. 50.48), Y(-25.61 .. -12.04)) # Note the space between .. -12\nplot(madagascar)","category":"page"},{"location":"#Methods-that-change-the-reslolution-or-extent-of-an-object","page":"Rasters.jl","title":"Methods that change the reslolution or extent of an object","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Click through to the function documentation for more in-depth descriptions and examples.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \naggregate aggregate data by the same or different amounts for each axis.\ndisaggregate similarly disaggregate data.\nmosaic join rasters covering different extents into a single array or file.\ncrop shrink objects to specific dimension sizes or the extent of another object.\nextend extend objects to specific dimension sizes or the extent of another object.\ntrim trims areas of missing values for arrays and across stack layers.\nresample resample data to a different size and projection, or snap to another object.\nwarp use gdalwarp on any object, e.g. a multidimensional NetCDF stack.","category":"page"},{"location":"#Methods-that-change-an-objects-values:","page":"Rasters.jl","title":"Methods that change an objects values:","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Note that most regular Julia methods, such as replace, work as for a standard Array. These additional methods are commonly required in GIS applications.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nclassify classify values into categories.\nmask mask an object by a polygon or Raster along X/Y, or other dimensions.\nreplace_missing replace all missing values in an object and update missingval.","category":"page"},{"location":"#Point,-polygon-and-table-operation","page":"Rasters.jl","title":"Point, polygon and table operation","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nrasterize rasterize points and geometries.\ncoverage get the fraction of each pixel covered by geometries.\nextract extract values from points or geometries.\nzonal calculate zonal statistics for an object masked by geometries.","category":"page"},{"location":"#Methods-to-load,-write-and-modify-data-sources:","page":"Rasters.jl","title":"Methods to load, write and modify data sources:","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":" \nmodify replace the data in objects. Useful to e.g. move objects to/from a GPU.\nread read data to memory if it is on disk.\nread! read data to predefined memory.\nopen open the underlying data for manually reading or writing.\nwrite write objects to file.","category":"page"},{"location":"#Altering-and-summarising-arrays-and-stacks-with-regular-julia-methods","page":"Rasters.jl","title":"Altering and summarising arrays and stacks with regular julia methods","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Most base methods work as for regular julia Arrays, such as reverse and rotations like rotl90. Base, statistics and linear algebra methods like mean that take a dims argument can also use the dimension name. To take the mean over the time dimension:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mean(A, dims=Ti)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"broadcast works lazily from disk when lazy=true, and is only applied when data is directly indexed. Adding a dot to any function will use broadcast over a Raster just like an Array. ","category":"page"},{"location":"#Broadcasting","page":"Rasters.jl","title":"Broadcasting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"For a disk-based array A, this will only be applied when indexing occurs or when we read the array.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A .*= 2","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"To broadcast directly to disk, we need to open the file in write mode:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"open(Raster(filename); write=true) do O\n    O .*= 2\nend","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"To broadcast over a RasterStack use map, which applies a function to the raster layers of the stack.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"newstack = map(stack) do raster\n    raster .* 2\nend","category":"page"},{"location":"#Modifying-object-properties","page":"Rasters.jl","title":"Modifying object properties","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild can be used to modify the fields of an object, generating a new object (but possibly holding the same arrays or files).","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"If you know that a file had an incorrectly specified missing value, you can do:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild(A; missingval=-9999)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"(replace_missing will actualy replace the current values)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Or if you need to change the name of the layer:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"rebuild(A; name=:temperature)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set can be used to modify the nested properties of an objects dimensions, that are more difficult to change with rebuild. set works on the principal that dimension properties can only be in one specific field, so we generally don't have to specify which one it is. set will also try to update anything affected by a change you make.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"This will set the X axis to specify points, instead of intervals:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set(A, X => Points)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"We can also reassign dimensions, here X becomes Z:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"set(A, X => Z)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"setcrs(A, crs) and setmappedcrs(A, crs) will set the crs value/s of an object to any GeoFormat from GeoFormatTypes.jl.","category":"page"},{"location":"#Examples-and-Plotting","page":"Rasters.jl","title":"Examples and Plotting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plots.jl and Makie.jl are fully supported by Rasters.jl, with recipes for plotting Raster and RasterStack provided. plot will plot a heatmap with axes matching dimension values. If mappedcrs is used, converted values will be shown on axes instead of the underlying crs values. contourf will similarly plot a filled contour plot.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Pixel resolution is limited to allow loading very large files quickly. max_res  specifies the maximum pixel resolution to show on the longest axis of the array. It can be set manually to change the resolution (e.g. for large or high-quality plots):","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{BioClim}, 5)\nplot(A; max_res=3000)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"For Makie, plot functions in a similar way.  plot will only accept two-dimensional rasters.  You can invoke contour, contourf, heatmap, surface or any Makie plotting function which supports surface-like data on a 2D raster.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"To obtain tiled plots for 3D rasters and RasterStacks, use the function Rasters.rplot([gridposition], raster; kw_args...).  This is an unexported function, since we're not sure how the API will change going forward.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CairoMakie # hide\nCairoMakie.activate!(px_per_unit = 2) # hide\nusing Rasters, CairoMakie, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{BioClim}, 5)\nMakie.plot(A)","category":"page"},{"location":"#Loading-and-plotting-data","page":"Rasters.jl","title":"Loading and plotting data","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Our first example simply loads a file from disk and plots it.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"This netcdf file only has one layer, if it has more we could use RasterStack instead. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, NCDatasets, Plots\nurl = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Objects with Dimensions other than X and Y will produce multi-pane plots. Here we plot every third month in the first year in one plot:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A[Ti=1:3:12] |> plot","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now plot the ocean temperatures around the Americas in the first month of 2001. Notice we are using lat/lon coordinates and date/time instead of regular indices. The time dimension uses DateTime360Day, so we need to load CFTime.jl to index it with Near.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CFTime\nA[Ti(Near(DateTime360Day(2001, 01, 17))), Y(-60.0 .. 90.0), X(45.0 .. 190.0)] |> plot ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now get the mean over the timespan, then save it to disk, and plot it as a filled contour:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Other plot functions and sliced objects that have only one X/Y/Z dimension fall back to generic DimensionalData.jl plotting, which will still correctly label plot axes.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Statistics\n# Take the mean\nmean_tos = mean(A; dims=Ti)","category":"page"},{"location":"#Plot-a-contour-plot","page":"Rasters.jl","title":"Plot a contour plot","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"contourf(mean_tos; dpi=300, size=(800, 400))","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Write the mean values to disk","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"write(\"mean_tos.nc\", mean_tos)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plotting recipes in DimensionalData.jl are the fallback for Rasters.jl when the object doesn't have 2 X/Y/Z dimensions, or a non-spatial plot command is used. So (as a random example) we could plot a transect of ocean surface temperature at 20 degree latitude :","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A[Y(Near(20.0)), Ti(1)] |> plot","category":"page"},{"location":"#A-basic-species-distribution-modelling-workflow","page":"Rasters.jl","title":"A basic species distribution modelling workflow","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Load occurrences for the Mountain Pygmy Possum using GBIF.jl","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, RasterDataSources, ArchGDAL, GBIF2, Plots \nrecords = GBIF2.occurrence_search(\"Burramys parvus\"; limit=300)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Extract the longitude/latitude value to a Vector of points (a Tuple counts as a (x, y) point in GeoInterface.jl):","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"coords = [(r.decimalLongitude, r.decimalLatitude) for r in records if !ismissing(r.decimalLatitude)]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Get BioClim layers and subset to south-east Australia","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A = RasterStack(WorldClim{BioClim}, (1, 3, 7, 12))\nse_aus = A[X(138 .. 155), Y(-40 .. -25)]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plot BioClim predictors and scatter occurrence points on all subplots","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"p = plot(se_aus);\nkw = (legend=:none, opacity=0.5, markershape=:cross, markercolor=:black)\nforeach(i -> scatter!(p, coords; subplot=i, kw...), 1:4)\ndisplay(p)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Then extract predictor variables and write to CSV.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CSV\npredictors = collect(extract(se_aus, coords))\nCSV.write(\"burramys_parvus_predictors.csv\", predictors)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Or convert them to a DataFrame.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using DataFrames\ndf = DataFrame(predictors)\ndf[1:5, :]","category":"page"},{"location":"#Polygon-masking,-mosaic-and-plot","page":"Rasters.jl","title":"Polygon masking, mosaic and plot","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"In this example we will mask the Scandinavian countries with border polygons, then mosaic together to make a single plot. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"First, get the country boundary shape files using GADM.jl.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, RasterDataSources, ArchGDAL, Shapefile, Plots, Dates, Downloads, NCDatasets\n\n# Download the shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary_lines.shp\"\nDownloads.download(shapefile_url, shapefile_name)\n\n# Load using Shapefile.jl\nshapes = Shapefile.Handle(shapefile_name)\ndenmark_border = shapes.shapes[71]\nnorway_border = shapes.shapes[53]\nsweden_border = shapes.shapes[54]","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Then load raster data. We load some worldclim layers using RasterDataSources via Rasters.jl:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"climate = RasterStack(WorldClim{Climate}, (:tmin, :tmax, :prec, :wind); month=July)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mask Denmark, Norway and Sweden from the global dataset using their border polygon, then trim the missing values. We pad trim with a 10 pixel margin.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"mask_trim(climate, poly) = trim(mask(climate; with=poly); pad=10)\n\ndenmark = mask_trim(climate, denmark_border)\nnorway = mask_trim(climate, norway_border)\nsweden = mask_trim(climate, sweden_border)","category":"page"},{"location":"#Plotting","page":"Rasters.jl","title":"Plotting","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"First define a function to add borders to all subplots.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"function borders!(p, poly) \n    for i in 1:length(p)\n        plot!(p, poly; subplot=i, fillalpha=0, linewidth=0.6)\n    end\n    return p\nend","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now we can plot the individual countries.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"dp = plot(denmark)\nborders!(dp, denmark_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"sp = plot(sweden)\nborders!(sp, sweden_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"np = plot(norway)\nborders!(np, norway_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"The Norway shape includes a lot of islands. Lets crop them out using .. intervals:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"norway_region = climate[X(0..40), Y(55..73)]\nplot(norway_region)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And mask it with the border again:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"norway = mask_trim(norway_region, norway_border)\nnp = plot(norway)\nborders!(np, norway_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Now we can combine the countries into a single raster using mosaic. first will take the first value if/when there is an overlap.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"scandinavia = mosaic(first, denmark, norway, sweden)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And plot scandinavia, with all borders included:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"p = plot(scandinavia)\nborders!(p, denmark_border)\nborders!(p, norway_border)\nborders!(p, sweden_border)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"And save to netcdf - a single multi-layered file, and tif, which will write a file for each stack layer.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"write(\"scandinavia.nc\", scandinavia)\nwrite(\"scandinavia.tif\", scandinavia)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl provides a range of other methods that are being added to over time. Where applicable these methods read and write lazily to and from disk-based arrays of common raster file types. These methods also work for entire RasterStacks and RasterSeries using the same syntax.","category":"page"},{"location":"#Plotting-in-Makie","page":"Rasters.jl","title":"Plotting in Makie","text":"","category":"section"},{"location":"#D-rasters-in-Makie","page":"Rasters.jl","title":"2-D rasters in Makie","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Plotting in Makie works somewhat differently than Plots, since the recipe system is different. You can pass a 2-D raster to any surface-like function (heatmap, contour, contourf, or even surface for a 3D plot) with ease.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using CairoMakie, Makie\nCairoMakie.activate!(px_per_unit = 2) # hide\nusing Rasters, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{BioClim}, 5) # this is a 3D raster, so is not accepted.\nB = A[:, :, 1] # this converts to a 2D raster which Makie accepts!\nfigure = Figure()\nplot(figure[1, 1], B)\ncontour(figure[1, 2], B)\nax = Axis(figure[2, 1]; aspect = DataAspect())\ncontourf!(ax, B)\nsurface(figure[2, 2], B) # even a 3D plot works!\nfigure","category":"page"},{"location":"#D-rasters-and-RasterStacks-in-Makie","page":"Rasters.jl","title":"3-D rasters and RasterStacks in Makie","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"warning: Warning\nThis interface is experimental, and unexported for that reason.  It may break at any time!","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Just as in Plots, 3D rasters are treated as a series of 2D rasters, which are tiled and plotted.  ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"You can use Rasters.rplot to visualize 3D rasters or RasterStacks in this way.  An example is below:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"stack = RasterStack(WorldClim{Climate}; month = 1)\nRasters.rplot(stack; Axis = (aspect = DataAspect(),))","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"You can pass any theming keywords in, which are interpreted by Makie appropriately.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"The plots seem a little squished here.  We provide a Makie theme which makes text a little smaller and has some other space-efficient attributes:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"CairoMakie.set_theme!(Rasters.theme_rasters())\nRasters.rplot(stack)","category":"page"},{"location":"#Plotting-with-Observables","page":"Rasters.jl","title":"Plotting with Observables","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.rplot should support Observable input out of the box, but the dimensions of that input must remain the same - i.e., the element names of a RasterStack must remain the same.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"stack_obs = Observable(stack)\nfig = Rasters.rplot(stack_obs) # `stack` is the WorldClim climate data for January\nrecord(fig, \"rplot.mp4\", 1:12; framerate = 3) do i\n    stack_obs[] = RasterStack(WorldClim{Climate}; month = i)\nend ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"(Image: )","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Makie\nMakie.set_theme!(Makie.minimal_default)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.rplot","category":"page"},{"location":"#Rasters.rplot","page":"Rasters.jl","title":"Rasters.rplot","text":"Rasters.rplot([position::GridPosition], raster; kw...)\n\nraster may be a Raster (of 2 or 3 dimensions) or a RasterStack whose underlying rasters are 2 dimensional, or 3-dimensional with a singleton (length-1) third dimension.\n\nKeywords\n\nplottype = Makie.Heatmap: The type of plot. Can be any Makie plot type which accepts a Raster; in practice, Heatmap, Contour, Contourf and Surface are the best bets.\naxistype = Makie.Axis: The type of axis. This can be an Axis, Axis3, LScene, or even a GeoAxis from GeoMakie.jl.\nX=X: The X dimension of the raster.\nY=Y: The Y dimension of the raster.\ndraw_colorbar = true: Whether to draw a colorbar for the axis or not.\ncolorbar_position = Makie.Right(): Indicates which side of the axis the colorbar should be placed on.  Can be Makie.Top(), Makie.Bottom(), Makie.Left(), or Makie.Right().\ncolorbar_padding = Makie.automatic: The amound of padding between the colorbar and its axis.  If automatic, then this is set to the width of the colorbar.\ntitle = Makie.automatic: The titles of each plot. If automatic, these are set to the name of the band.\nxlabel = Makie.automatic: The x-label for the axis. If automatic, set to the dimension name of the X-dimension of the raster.\nylabel = Makie.automatic: The y-label for the axis. If automatic, set to the dimension name of the Y-dimension of the raster.\ncolorbarlabel = \"\": Usually nothing, but here if you need it. Sets the label on the colorbar.\ncolormap = nothing: The colormap for the heatmap. This can be set to a vector of colormaps (symbols, strings, cgrads) if plotting a 3D raster or RasterStack.\ncolorrange = Makie.automatic: The colormap for the heatmap.  This can be set to a vector of (low, high) if plotting a 3D raster or RasterStack.\nnan_color = :transparent: The color which NaN values should take. Default to transparent.\n\n\n\n\n\n","category":"function"},{"location":"#Objects","page":"Rasters.jl","title":"Objects","text":"","category":"section"},{"location":"#Raster","page":"Rasters.jl","title":"Raster","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Spatial raster data is essentially just an Array. But Raster wrappers allow treating them as an array that maintains its spatial index, crs and other metadata through all transformations. This means they can always be plotted and written to disk after applying most base Julia methods, and most broadcasts.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRaster\nRaster\nRaster(T::Type{<:RasterDataSources.RasterDataSource}, layer)","category":"page"},{"location":"#Rasters.AbstractRaster","page":"Rasters.jl","title":"Rasters.AbstractRaster","text":"AbstractRaster <: DimensionalData.AbstractDimArray\n\nAbstract supertype for objects that wrap an array (or location of an array)  and metadata about its contents. It may be memory or hold a FileArray, which holds the filename, and is only opened when required.\n\nAbstractRasters inherit from AbstractDimArray from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl Dimensions. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with getindex or view. getindex on a AbstractRaster will always return a memory-backed Raster.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Raster","page":"Rasters.jl","title":"Rasters.Raster","text":"Raster <: AbsractRaster\n\nRaster(filepath::AbstractString, dims; kw...)\nRaster(A::AbstractArray{T,N}, dims; kw...)\nRaster(A::AbstractRaster; kw...)\n\nA generic AbstractRaster for spatial/raster array data. It may hold memory-backed arrays or FileArray, that simply holds the String path to an unopened file. This will only be opened lazily when it is indexed with getindex or when read(A) is called. Broadcasting, taking a view, reversing and most other  methods do not load data from disk: they are applied later, lazily.\n\nKeywords\n\ndims: Tuple of Dimensions for the array.\nlazy: A Bool specifying if to load the stack lazily from disk. false by default.\nname: Symbol name for the array, which will also retreive named layers if Raster   is used on a multi-layered file like a NetCDF.\nmissingval: value reprsenting missing data, normally detected form the file. Set manually   when you know the value is not specified or is incorrect. This will not change any   values in the raster, it simply assigns which value is treated as missing. To replace all of   the missing values in the raster, use replace_missing.\nmetadata: ArrayMetadata object for the array, or NoMetadata().\ncrs: the coordinate reference system of  the objects XDim/YDim dimensions.    Only set this if you know the detected crs is incrorrect, or it is not present in   the file. The crs is expected to be a GeoFormatTypes.jl CRS or Mixed GeoFormat type. \nmappedcrs: the mapped coordinate reference system of the objects XDim/YDim dimensions.   for Mapped lookups these are the actual values of the index. For Projected lookups   this can be used to index in eg. EPSG(4326) lat/lon values, having it converted automatically.   Only set this if the detected mappedcrs in incorrect, or the file does not have a mappedcrs,   e.g. a tiff. The mappedcrs is expected to be a GeoFormatTypes.jl CRS or Mixed GeoFormat type. \ndropband: drop single band dimensions. true by default.\n\nInternal Keywords\n\nIn some cases it is possible to set these keywords as well.\n\ndata: can replace the data in an AbstractRaster\nrefdims: Tuple of position Dimensions the array was sliced from, defaulting to ().\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Raster-Tuple{Type{<:RasterDataSources.RasterDataSource}, Any}","page":"Rasters.jl","title":"Rasters.Raster","text":"Raster(T::Type{<:RasterDataSource}, [layer]; kw...) => Raster\n\nLoad a RasterDataSource as an Raster. T and layers are are passed to RasterDataSources.getraster, while kw args are for both getraster and Raster.\n\nKeywords\n\nmonth: an Int between 1 and 12, usually for Climate datasets\ndate: a DateTime object, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nMODIS datasets require a specific set of keyword arguments:\n\nlat and lon: Coordinates in decimal degrees (Floats ) of the center of the raster\nkm_ab and km_lr: Kilometers above/below and left/right (Integers up to 100) of the center of the raster\n\nOther Raster keywords are passed to the Raster constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#RasterStack","page":"Rasters.jl","title":"RasterStack","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Spatial data often comes as a bundle of multiple named arrays, as in netcdf. RasterStack can represent this, or multiple files organised in a similar way.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRasterStack\nRasterStack\nRasterStack(T::Type{<:RasterDataSources.RasterDataSource})","category":"page"},{"location":"#Rasters.AbstractRasterStack","page":"Rasters.jl","title":"Rasters.AbstractRasterStack","text":"AbstractRasterStack\n\nAbstract supertype for objects that hold multiple AbstractRasters that share spatial dimensions.\n\nThey are NamedTuple-like structures that may either contain NamedTuple of AbstractRasters, string paths that will load AbstractRasters, or a single path that points to a file containing multiple layers, like NetCDF or HDF5. Use and syntax is similar or identical for all cases.\n\nAbstractRasterStack can hold layers that share some or all of their dimensions. They cannot have the same dimension with different length or spatial extent as another layer.\n\ngetindex on an AbstractRasterStack generally returns a memory backed standard Raster. raster[:somelayer] |> plot plots the layers array, while raster[:somelayer, X(1:100), Band(2)] |> plot will plot the subset without loading the whole array.\n\ngetindex on an AbstractRasterStack with a key returns another stack with getindex applied to all the arrays in the stack.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterStack","page":"Rasters.jl","title":"Rasters.RasterStack","text":"RasterStack <: AbstrackRasterStack\n\nRasterStack(data...; name, kw...)\nRasterStack(data::Union{Vector,Tuple}; name, kw...)\nRasterStack(data::NamedTuple; kw...))\nRasterStack(s::AbstractRasterStack; kw...)\nRasterStack(s::AbstractRaster; layersfrom=Band, kw...)\nRasterStack(filename::AbstractString; kw...)\n\nLoad a file path or a NamedTuple of paths as a RasterStack, or convert arguments, a Vector or NamedTuple of Rasters to RasterStack.\n\nArguments\n\ndata: A NamedTuple of Rasters, or a Vector, Tuple or splatted arguments   of Raster. The latter options must pass a name keyword argument.\nfilename: A file (such as netcdf or tif) to be loaded as a stack, or a directory path   containing multiple files.\n\nKeywords\n\nname: Used as stack layer names when a Tuple, Vector or splat of Raster is passed in.   Has no effect when NameTuple is used - the NamedTuple keys are the layer names.\nmetadata: A Dict or DimensionalData.Metadata object.\nrefdims: Tuple of Dimension that the stack was sliced from.\nlayersfrom: Dimension to source stack layers from if the file is not already multi-layered.   nothing is default, so that a single RasterStack(raster) is a single layered stack.   RasterStack(raster; layersfrom=Band) will use the bands as layers.\nlazy: A Bool specifying whether to load the stack lazily from disk. false by default.\ndropband: drop single band dimensions when creating stacks from filenames. true by default.\n\nfiles = (temp=\"temp.tif\", pressure=\"pressure.tif\", relhum=\"relhum.tif\")\nstack = RasterStack(files; mappedcrs=EPSG(4326))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterStack-Tuple{Type{<:RasterDataSources.RasterDataSource}}","page":"Rasters.jl","title":"Rasters.RasterStack","text":"RasterStack(T::Type{<:RasterDataSource}, [layers::Union{Symbol,AbstractArray,Tuple}]; kw...) => RasterStack\n\nLoad a RasterDataSource as an RasterStack. T and layers are passed to RasterDataSources.getraster, while kw args are for both getraster and RasterStack.\n\nKeywords\n\nmonth: an Int between 1 and 12, usually for Climate datasets.\ndate: a DateTime object, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nMODIS datasets require a specific set of keyword arguments:\n\nlat and lon: Coordinates in decimal degrees (Floats ) of the center of the raster\nkm_ab and km_lr: Kilometers above/below and left/right (Integers up to 100) of the center of the raster\n\nOther RasterStack keywords are passed to the RasterStack constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#RasterSeries","page":"Rasters.jl","title":"RasterSeries","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"A series is a meta-array that holds other files/data that is distributed over some dimension, often time. These files/data can be Rasters or RasterStacks.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"AbstractRasterSeries\nRasterSeries\nRasterSeries(T::Type{<:RasterDataSources.RasterDataSource})","category":"page"},{"location":"#Rasters.AbstractRasterSeries","page":"Rasters.jl","title":"Rasters.AbstractRasterSeries","text":"AbstractRasterSeries <: DimensionalData.AbstractDimensionalArray\n\nAbstract supertype for high-level DimensionalArray that hold RasterStacks, Rasters, or the paths they can be loaded from. RasterSeries are indexed with dimensions as with a AbstractRaster. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation.\n\nAs much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows syntax like below for a series of stacks of arrays:\n\nRasterSeries[Time(Near(DateTime(2001, 1))][:temp][Y(Between(70, 150)), X(Between(-20,20))] |> plot`\n\nRasterSeries is the concrete implementation.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterSeries","page":"Rasters.jl","title":"Rasters.RasterSeries","text":"RasterSeries <: AbstractRasterSeries\n\nRasterSeries(rasters::AbstractArray{<:AbstractRaster}, dims; [refdims])\nRasterSeries(stacks::AbstractArray{<:AbstractRasterStack}, dims; [refdims]) \n\nRasterSeries(paths::AbstractArray{<:AbstractString}, dims; child, duplicate_first, kw...)\nRasterSeries(path:::AbstractString, dims; ext, separator, child, duplicate_first, kw...)\n\nConcrete implementation of AbstractRasterSeries.\n\nA RasterSeries is an array of Rasters or RasterStacks, along some dimension(s).\n\nExisting Raster RasterStack can be wrapped in a RasterSeries, or new files  can be loaded from an array of String or from a single String.\n\nA single String can refer to a whole directory, or the name of a series of files in a directory, sharing a common stem. The differnce between the filenames can be used as the lookup for the series. \n\nFor example, with some tifs at these paths : \n\n\"series_dir/myseries_2001-01-01T00:00:00.tif\"\n\"series_dir/myseries_2002-01-01T00:00:00.tif\"\n\nWe can load a RasterSeries with a DateTime lookup:\n\njulia> ser = RasterSeries(\"series_dir/myseries.tif\", Ti(DateTime))\n2-element RasterSeries{Raster,1} with dimensions: \n  Ti Sampled{DateTime} DateTime[DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")] ForwardOrdered Irregular Points\n\nThe DateTime suffix is parsed from the filenames. Using Ti(Int) would try to parse integers intead.\n\nJust using the directory will also work, unless there are other files mixed in it:\n\njulia> ser = RasterSeries(\"series_dir\", Ti(DateTime))\n2-element RasterSeries{Raster,1} with dimensions: \n  Ti Sampled{DateTime} DateTime[DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")] ForwardOrdered Irregular Points\n\nArguments\n\ndims: series dimension/s.\n\nKeywords\n\nWhen loading a series from a Vector of String paths or a single String path:\n\nchild: constructor of child objects for use when filenames are passed in,   can be Raster or RasterStack. Defaults to Raster.\nduplicate_first::Bool: wether to duplicate the dimensions and metadata of the   first file with all other files. This can save load time with a large   series where dimensions are identical. false by default.\nlazy: load files lazily, false by default.\nkw: keywords passed to the child constructor Raster or RasterStack.\n\nWhen loading a series from a single String path:\n\next: filename extension such as \".tiff\" or \".nc\".    Use to specify a subset of files if only a directory path is passed in.\nseparator: separator used to split lookup elements from the rest of a filename. '_' by default.\n\nOthers:\n\nrefdims: existing reference dimension/s, normally not required.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterSeries-Tuple{Type{<:RasterDataSources.RasterDataSource}}","page":"Rasters.jl","title":"Rasters.RasterSeries","text":"RasterSeries(T::Type{<:RasterDataSource}, [layers::Union{Symbol,AbstractArray,Tuple}]; kw...) => AbstractRasterSeries\n\nLoad a RasterDataSource as an AbstractRasterSeries. T, args are are passed to RasterDataSource.getraster, while kw args are for both getraster and RasterSeries.\n\nKeywords\n\nmonth: a Vector or range of Int between 1 and 12, usually for Climate datasets.\ndate: a Vector of DateTime objects, usually for Weather datasets.\nres: a String resolution, for datasets with multiple resolutions.\n\nMODIS datasets require a specific set of keyword arguments:\n\nlat and lon: Coordinates in decimal degrees (Floats ) of the center of the raster\nkm_ab and km_lr: Kilometers above/below and left/right (Integers up to 100) of the center of the raster\n\nOther RasterSeries keywords are passed to the RasterSeries constructor.\n\nSee the docs for  RasterDatasources.getraster for more specific details about data sources, layers and keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#Dimensions","page":"Rasters.jl","title":"Dimensions","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters uses X, Y, and Z dimensions from DimensionalData.jl to represent spatial directions like longitude, latitude and the vertical dimension, and subset data with them. Ti is used for time, and Band represent bands. Other dimensions can have arbitrary names, but will be treated generically. See DimensionalData.jl for more details on how they work. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Band","category":"page"},{"location":"#Rasters.Band","page":"Rasters.jl","title":"Rasters.Band","text":"Band <: Dimension\n\nBand(val=:)\n\nBand Dimension for multi-band rasters.\n\nExample:\n\nbanddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n\n\n\n\n\n","category":"type"},{"location":"#Lookup-Arrays","page":"Rasters.jl","title":"Lookup Arrays","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These specify properties of the index associated with e.g. the X and Y dimension. Rasters.jl defines additional lookup arrays: Projected to handle dimensions with projections, and Mapped where the projection is mapped to another projection like EPSG(4326). Mapped is largely designed to handle NetCDF dimensions, especially with Explicit spans.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.AbstractProjected\nProjected\nMapped","category":"page"},{"location":"#Rasters.AbstractProjected","page":"Rasters.jl","title":"Rasters.AbstractProjected","text":"AbstractProjected <: AbstractSampled\n\nAbstract supertype for projected index lookups.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Projected","page":"Rasters.jl","title":"Rasters.Projected","text":"Projected <: AbstractProjected\n\nProjected(order, span, sampling, crs, mappedcrs)\nProjected(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs, mappedcrs=nothing)\n\nAn AbstractSampled LookupArray with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nIf both crs and mappedcrs fields contain CRS data (in a GeoFormat wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified mappedcrs projection automatically. A common use case would be to pass mappedcrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; mappedcrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf mappedcrs is not supplied (ie. mappedcrs=nothing), the base index will be shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.Mapped","page":"Rasters.jl","title":"Rasters.Mapped","text":"Mapped <: AbstractProjected\n\nMapped(order, span, sampling, crs, mappedcrs)\nMapped(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs=nothing, mappedcrs)\n\nAn AbstractSampled LookupArray, where the dimension index has been mapped to another projection, usually lat/lon or EPSG(4326). Mapped matches the dimension format commonly used in netcdf files.\n\nFields and behaviours are identical to Sampled with the addition of crs and mappedcrs fields.\n\nThe mapped dimension index will be used as for Sampled, but to save in another format the underlying crs may be used to convert it.\n\n\n\n\n\n","category":"type"},{"location":"#Data-sources","page":"Rasters.jl","title":"Data sources","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl uses a number of backends to load raster data. Raster, RasterStack and RasterSeries will detect which backend to use for you, automatically.","category":"page"},{"location":"#GRD","page":"Rasters.jl","title":"GRD","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"R GRD files can be loaded natively, using Julias MMap - which means they are very fast, but are not compressed. They are always 3 dimensional, and have Y, X and Band dimensions.","category":"page"},{"location":"#NetCDF","page":"Rasters.jl","title":"NetCDF","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"NetCDF .nc files are loaded using NCDatasets.jl. Layers from files can be loaded as Raster(\"filename.nc\"; key=:layername). Without key the first layer is used. RasterStack(\"filename.nc\") will use all netcdf variables in the file that are not dimensions as layers. ","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"NetCDF layers can have arbitrary dimensions. Known, common dimension names are converted to X, Y Z, and Ti, otherwise Dim{:layername} is used. Layers in the same file may also have different dimensions.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"NetCDF files still have issues loading directly from disk for some operations. Using read(ncstack) may help.","category":"page"},{"location":"#GDAL","page":"Rasters.jl","title":"GDAL","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"All files GDAL can access, such as .tiff and .asc files, can be loaded, using ArchGDAL.jl. These are generally best loaded as Raster(\"filename.tif\"), but can be loaded as RasterStack(\"filename.tif\"; layersfrom=Band), taking layers from the Band dimension, which is also the default.","category":"page"},{"location":"#SMAP","page":"Rasters.jl","title":"SMAP","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"The Soil Moisture Active-Passive dataset provides global layers of soil moisture, temperature and other related data, in a custom HDF5 format. Layers are always 2 dimensional, with Y and X dimensions.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These can be loaded as multi-layered RasterStack(\"filename.h5\"). Individual layers can be loaded as Raster(\"filename.h5\"; key=:layerkey), without key the first layer is used.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"smapseries","category":"page"},{"location":"#Rasters.smapseries","page":"Rasters.jl","title":"Rasters.smapseries","text":"smapseries(filenames::AbstractString; kw...)\nsmapseries(filenames::Vector{<:AbstractString}, dims=nothing; kw...)\n\nRasterSeries loader for SMAP files and whole folders of files, organised along the time dimension. Returns a RasterSeries.\n\nArguments\n\nfilenames: A String path to a directory of SMAP files,   or a vector of String paths to specific files.\ndims: Tuple containing Ti dimension for the series.   Automatically generated form filenames unless passed in.\n\nKeywords\n\nkw: Passed to RasterSeries.\n\n\n\n\n\n","category":"function"},{"location":"#Writing-file-formats-to-disk","page":"Rasters.jl","title":"Writing file formats to disk","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Files can be written to disk in all formats other than SMAP HDF5 using write(\"filename.ext\", A). See the docs for write. They can (with some caveats) be written to different formats than they were loaded in as, providing file-type conversion for spatial data.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Some metadata may be lost in formats that store little metadata, or where metadata conversion has not been completely implemented.","category":"page"},{"location":"#RasterDataSources.jl-integration","page":"Rasters.jl","title":"RasterDataSources.jl integration","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"RasterDataSources.jl standardises the download of common raster data sources, with a focus on datasets used in ecology and the environmental sciences. RasterDataSources.jl is tightly integrated into Rasters.jl, so that datsets and keywords can be used directly to download and load data as a Raster, RasterStack, or RasterSeries.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"using Rasters, RasterDataSources, ArchGDAL, Plots, Dates\nA = Raster(WorldClim{Climate}, :tavg; month=June)\nplot(A)","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"See the docs for Raster, RasterStack and RasterSeries, and the docs for RasterDataSources.getraster for syntax to specify various data sources.","category":"page"},{"location":"#Exported-functions","page":"Rasters.jl","title":"Exported functions","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.jl is a direct extension of DimensionalData.jl. See DimensionalData.jl docs for the majority of types and functions that can be used in Rasters.jl.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Functions more specific to geospatial data are included in Rasters.jl, and listed below.","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"aggregate\naggregate!\nboolmask\nclassify \nclassify!\ncoverage\ncoverage!\nconvertlookup\ncrop\ncrs\ndisaggregate\ndisaggregate!\nextend\nextract\nmappedcrs\nmappedbounds\nmappedindex\nmask\nmask!\nmissingval\nmissingmask\nmosaic\nmosaic!\npoints\nrasterize\nrasterize!\nresample\nreplace_missing\nreproject\nsetcrs\nsetmappedcrs\nskipmissing\ntrim\nwarp\nzonal","category":"page"},{"location":"#Rasters.aggregate","page":"Rasters.jl","title":"Rasters.aggregate","text":"aggregate(method, object, scale; filename, progress, skipmissing)\n\nAggregate a Raster, or all arrays in a RasterStack or RasterSeries, by scale using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that specifies where to sample from in the interval.\nobject: Object to aggregate, like AbstractRasterSeries, AbstractStack, AbstractRaster or Dimension.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\nWhen the aggregation scale of is larger than the array axis, the length of the axis is used.\n\nKeywords\n\nskipmissingval: if true, any missingval will be skipped during aggregation, so that   only areas of all missing values will be aggregated to missingval. If false, any   aggegrated area containing a missingval will be assigned missingval.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\nprogress: show a progress bar, true by default, false to hide.\n\nExample\n\nusing Rasters, RasterDataSources, Statistics, Plots\nusing Rasters: Center\nst = read(RasterStack(WorldClim{Climate}; month=1))\nag = aggregate(Center(), st, (Y(20), X(20)); skipmissingval=true, progress=false)\nplot(ag)\nsavefig(\"build/aggregate_example.png\"); nothing\n# output\n\n\n(Image: aggregate)\n\nNote: currently it is faster to aggregate over memory-backed arrays. Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.aggregate!","page":"Rasters.jl","title":"Rasters.aggregate!","text":"aggregate!(method, dst::AbstractRaster, src::AbstractRaster, scale; skipmissingval=false)\n\nAggregate array src to array dst by scale, using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\nWhen the aggregation scale of is larger than the array axis, the length of the axis is used.\n\nKeywords\n\nprogress: show a progress bar.\nskipmissingval: if true, any missingval will be skipped during aggregation, so that   only areas of all missing values will be aggregated to missingval. If false, any   aggegrated area containing a missingval will be assigned missingval.\n\nNote: currently it is much faster to aggregate over memory-backed arrays. Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.boolmask","page":"Rasters.jl","title":"Rasters.boolmask","text":"boolmask(obj::Raster; [missingval])\nboolmask(obj; [to, res, size])\n\nCreate a mask array of Bool values, from another Raster. An AbstractRasterStack or AbstractRasterSeries are also accepted, but a mask is taken of the first layer or object not all of them.\n\nThe array returned from calling boolmask on a AbstractRaster is a Raster with the same dimensions as the original array and a missingval of false.\n\nArguments\n\nobj: a Raster, a GeoInterface.jl geometry, or a vector or table of geometries.\n\nRaster / RasterStack Keywords\n\nmissingval: The missing value of the source array, with default missingval(raster).\n\nGeometry keywords\n\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from the geometries,   Additionally, when no to object or an Extent is passed for to, the size   or res keyword must also be used.\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\ncrs: a crs which will be attached to the resulting raster when to not passed  or is an Extent. Otherwise the crs from to is used.\nshape: Force data to be treated as :polygon, :line or :point geometries.   using points or lines as polygons may have unexpected results.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the polygon :touches the pixel, or that are completely :inside the polygon.   The default is :center.\n\nAnd specifically for shape=:polygon:\n\nboundary: include pixels where the :center is inside the polygon, where   the line :touches the pixel, or that are completely :inside inside the polygon.   The default is :center.\n\nFor tabular data, feature collections and other iterables\n\ncollapse: if true, collapse all geometry masks into a single mask. Otherwise   return a Raster with an additional geometry dimension, so that each slice   along this axis is the mask of the geometry opbject of each row of the   table, feature in the feature collection, or just each geometry in the iterable.\n\nExample\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nboolmask(wc) |> plot\n\nsavefig(\"build/boolmask_example.png\"); nothing\n\n# output\n\n(Image: boolmask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.classify","page":"Rasters.jl","title":"Rasters.classify","text":"classify(x, pairs; lower=(>=), upper=(<), others=nothing)\nclassify(x, pairs...; lower, upper, others)\n\nCreate a new array with values in x classified by the values in pairs.\n\npairs can hold tuples fo values (2, 3), a Fix2 function e.g. <=(1), a Tuple of Fix2 e.g. (>=(4), <(7)), or an IntervalSets.jl interval, e.g. 3..9 or OpenInterval(10, 12). pairs can also be a n * 3 matrix where each row is lower bounds, upper bounds, replacement.\n\nIf tuples or a Matrix are used, the lower and upper keywords define how the lower and upper boundaries are chosen.\n\nIf others is set other values not covered in pairs will be set to that values.\n\nArguments\n\nx: a Raster or RasterStack\npairs: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of Fix2 like (>(x), <(y).\n\nKeywords\n\nlower: Which comparison (< or <=) to use for lower values, if Fix2 are not used.\nupper: Which comparison (> or >=) to use for upper values, if Fix2 are not used.\nothers: A value to assign to all values not included in pairs.   Passing nothing (the default) will leave them unchanged.\n\nExample\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{Climate}, :tavg; month=1)\nclasses = <=(15) => 10,\n          15..25 => 20,\n          25..35 => 30,\n          >(35) => 40\nclassified = classify(A, classes; others=0, missingval=0)\nplot(classified; c=:magma)\n\nsavefig(\"build/classify_example.png\"); nothing\n\n# output\n\n(Image: classify)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.classify!","page":"Rasters.jl","title":"Rasters.classify!","text":"classify!(x, pairs...; lower, upper, others)\nclassify!(x, pairs; lower, upper, others)\n\nClassify the values of x in-place, by the values in pairs.\n\nIf Fix2 is not used, the lower and upper keywords\n\nIf others is set other values not covered in pairs will be set to that values.\n\nArguments\n\nx: a Raster or RasterStack\npairs: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of Fix2 like (>(x), <(y).\n\nKeywords\n\nlower: Which comparison (< or <=) to use for lower values, if Fix2 are not used.\nupper: Which comparison (> or >=) to use for upper values, if Fix2 are not used.\nothers: A value to assign to all values not included in pairs.   Passing nothing (the default) will leave them unchanged.\n\nExample\n\nclassify! to disk, with key steps:\n\ncopying a tempory file so we don't write over the RasterDataSources.jl version.\nuse open with write=true to open the file with disk-write permissions.\nuse Float32 like 10.0f0 for all our replacement values and other, because   the file is stored as Float32. Attempting to write some other type will fail.\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots\n# Download and copy the file\nfilename = getraster(WorldClim{Climate}, :tavg; month=6)\ntempfile = tempname() * \".tif\"\ncp(filename, tempfile)\n# Define classes\nclasses = (5, 15) => 10,\n          (15, 25) => 20,\n          (25, 35) => 30,\n          >=(35) => 40\n# Open the file with write permission\nopen(Raster(tempfile); write=true) do A\n    classify!(A, classes; others=0)\nend\n# Open it again to plot the changes\nplot(Raster(tempfile); c=:magma)\n\nsavefig(\"build/classify_bang_example.png\"); nothing\n\n# output\n\n(Image: classify!)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.coverage","page":"Rasters.jl","title":"Rasters.coverage","text":"coverage(mode, geom; [to, res, size, scale, verbose, progress])\ncoverage(geom; [to, mode, res, size, scale, verbose, progress])\n\nCalculate the area of a raster covered by GeoInterface.jl compatible geomtry geom, as a fraction.\n\nEach pixel is assigned a grid of points (by default 10 x 10) that are each checked to be inside the geometry. The sum divided by the number of points to give coverage.\n\nIn pracice, most pixel coverage is not calculated this way - shortcuts that  produce the same result are taken wherever possible.\n\nIf geom is an AbstractVector or table, the mode keyword will determine how coverage is combined.\n\nKeywords\n\nmode: method for combining multiple geometries - union or sum. \nunion (the default) gives the areas covered by all geometries. Usefull in spatial coverage where overlapping regions should not be counted twice. The returned raster will contain Float64 values between 0.0 and 1.0.\nsum gives the summed total of the areas covered by all geometries, as in taking the sum of running coverage separately on all geometries. The returned values are positive Float64.\nFor a single geometry, the mode keyword has no effect - the result is the same.\nscale: Integer scale of pixel subdivision. The default of 10 means each pixel has    10 x 10 or 100 points that contribute to coverage. Using 100 means 10,000 points   contribute. Performance will decline as scale increases. Memory use will grow    by scale^2 when mode=:union.\nprogress: show a progress bar, true by default, false to hide.\nvebose: whether to print messages about potential problems. true by default.\n\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from the geometries,   Additionally, when no to object or an Extent is passed for to, the size   or res keyword must also be used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.coverage!","page":"Rasters.jl","title":"Rasters.coverage!","text":"coverage!(A, geom; [mode, scale])\n\nCalculate the area of a raster covered by GeoInterface.jl compatible geomtry geom, as a fraction.\n\nEach pixel is assigned a grid of points (by default 10 x 10) that are each checked to be inside the geometry. The sum divided by the number of points to give coverage.\n\nIn pracice, most pixel coverage is not calculated this way - shortcuts that  produce the same result are taken wherever possible.\n\nIf geom is an AbstractVector or table, the mode keyword will determine how coverage is combined.\n\nKeywords\n\nmode: method for combining multiple geometries - union or sum. \nunion (the default) gives the areas covered by all geometries. Usefull in spatial coverage where overlapping regions should not be counted twice. The returned raster will contain Float64 values between 0.0 and 1.0.\nsum gives the summed total of the areas covered by all geometries, as in taking the sum of running coverage separately on all geometries. The returned values are positive Float64.\nFor a single geometry, the mode keyword has no effect - the result is the same.\nscale: Integer scale of pixel subdivision. The default of 10 means each pixel has    10 x 10 or 100 points that contribute to coverage. Using 100 means 10,000 points   contribute. Performance will decline as scale increases. Memory use will grow    by scale^2 when mode=:union.\nprogress: show a progress bar, true by default, false to hide.\nvebose: whether to print messages about potential problems. true by default.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.convertlookup","page":"Rasters.jl","title":"Rasters.convertlookup","text":"convertlookup(dstlookup::Type{<:LookupArray}, x)\n\nConvert the dimension lookup between Projected and Mapped. Other dimension lookups pass through unchanged.\n\nThis is used to e.g. save a netcdf file to GeoTiff.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.crop","page":"Rasters.jl","title":"Rasters.crop","text":"crop(x; to)\ncrop(xs...; to)\n\nCrop one or multiple AbstractRaster or AbstractRasterStack x to match the size of the object to, or smallest of any dimensions that are shared.\n\ncrop is lazy, using a view into the object rather than alocating new memory.\n\nKeywords\n\nto: the object to crop to. If to keyword is passed, the smallest shared   area of all xs is used.\ntouches: true or false. Whether to use Touches wraper on the object extent.  When lines need to be included in e.g. zonal statistics, true shoudle be used.\n\nAs crop is lazy, filename and suffix keywords are not used.\n\nExample\n\nCrop to another raster:\n\nusing Rasters, RasterDataSources, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out New Zealand from the evenness raster\nnz_bounds = X(165 .. 180), Y(-50 .. -32)\nnz_evenness = evenness[nz_bounds...]\n\n# Crop range to match evenness\nnz_range = crop(rnge; to=nz_evenness)\nplot(nz_range)\n\nsavefig(\"build/nz_crop_example.png\")\nnothing\n\n# output\n\n(Image: new zealand evenness cropped)\n\nCrop to a polygon:\n\nusing Rasters, RasterDataSources, Plots, Dates, Shapefile, Downloads\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\nshp = Shapefile.Handle(shapefile_name).shapes[6]\n\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nargentina_evenness = crop(evenness; to=shp)\nplot(argentina_evenness)\n\nsavefig(\"build/argentina_crop_example.png\"); nothing\n\n# output\n\n(Image: argentina evenness cropped)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.crs","page":"Rasters.jl","title":"Rasters.crs","text":"crs(x)\n\nGet the projected coordinate reference system of a Y or X Dimension, or of the Y/X dims of an AbstractRaster.\n\nFor Mapped lookup this may be nothing as there may be no projected coordinate reference system at all. See setcrs to set it manually.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.disaggregate","page":"Rasters.jl","title":"Rasters.disaggregate","text":"disaggregate(method, object, scale; filename, progress, keys)\n\nDisaggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractRasterSeries, AbstractStack, AbstractRaster or a Dimension.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\nKeywords\n\nprogress: show a progress bar.\n\nNote: currently it is faster to aggregate over memory-backed arrays. Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.disaggregate!","page":"Rasters.jl","title":"Rasters.disaggregate!","text":"disaggregate!(method, dst::AbstractRaster, src::AbstractRaster, filename, scale)\n\nDisaggregate array src to array dst by some scale, using method.\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\nNote: currently it is faster to aggregate over memory-backed arrays. Use read on src before use where required.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.extend","page":"Rasters.jl","title":"Rasters.extend","text":"extend(xs...; [to])\nextend(xs; [to])\nextend(x::Union{AbstractRaster,AbstractRasterStack}; to, kw...)\n\nExtend one or multiple AbstractRaster to match the area covered by all xs, or by the keyword argument to.\n\nKeywords\n\nto: the Raster or dims to extend to. If no to keyword is passed, the largest   shared area of all xs is used.\ntouches: true or false. Whether to use Touches wraper on the object extent.  When lines need to be included in e.g. zonal statistics, true shoudle be used.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nusing Rasters, RasterDataSources, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out South America\nsa_bounds = X(-88 .. -32), Y(-57 .. 13)\nsa_evenness = evenness[sa_bounds...]\n\n# Extend range to match the whole-world raster\nsa_range = extend(sa_evenness; to=rnge)\nplot(sa_range)\n\nsavefig(\"build/extend_example.png\")\nnothing\n# output\n\n(Image: extend)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.extract","page":"Rasters.jl","title":"Rasters.extract","text":"extract(x, geoms; atol)\n\nExtracts the value of Raster or RasterStack at given points, returning an iterable of NamedTuple with properties for :geometry and raster or stack layer values.\n\nNote that if objects have more dimensions than the length of the point tuples, sliced arrays or stacks will be returned instead of single values.\n\nArguments\n\nx: a Raster or RasterStack to extract values from.\ngeoms: GeoInterface.jl compatible geometries, or tables or iterables of geometries.\n\nKeywords\n\natol: a tolorerance for floating point lookup values for when the LookupArray   contains Points. atol is ignored for Intervals.\n\nExample\n\nHere we extact points matching the occurrence of the Mountain Pygmy Possum, Burramis parvus. This could be used to fit a species distribution model.\n\nusing Rasters, RasterDataSources, ArchGDAL, GBIF2, CSV\n\n# Get a stack of BioClim layers, and replace missing values with `missing`\nst = RasterStack(WorldClim{BioClim}, (1, 3, 5, 7, 12)) |> replace_missing\n\n# Download some occurrence data\nobs = GBIF2.occurrence_search(\"Burramys parvus\"; limit=5, year=\"2009\")\n\n# Convert observations to points\npnts = collect((o.decimalLongitude, o.decimalLatitude) for o in obs if !ismissing(o.decimalLongitude))\n\n# use `extract` to get values for all layers at each observation point.\n# We `collect` to get a `Vector` from the lazy iterator.\ncollect(extract(st, pnts))\n\n# output\n5-element Vector{NamedTuple{(:geometry, :bio1, :bio3, :bio5, :bio7, :bio12)}}:\n (geometry = (0.21, 40.07), bio1 = 17.077084f0, bio3 = 41.20417f0, bio5 = 30.1f0, bio7 = 24.775f0, bio12 = 446.0f0)\n (geometry = (0.03, 39.97), bio1 = 17.076923f0, bio3 = 39.7983f0, bio5 = 29.638462f0, bio7 = 24.153847f0, bio12 = 441.0f0)\n (geometry = (0.03, 39.97), bio1 = 17.076923f0, bio3 = 39.7983f0, bio5 = 29.638462f0, bio7 = 24.153847f0, bio12 = 441.0f0)\n (geometry = (0.52, 40.37), bio1 = missing, bio3 = missing, bio5 = missing, bio7 = missing, bio12 = missing)\n (geometry = (0.32, 40.24), bio1 = 16.321388f0, bio3 = 41.659454f0, bio5 = 30.029825f0, bio7 = 25.544561f0, bio12 = 480.0f0)\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedcrs","page":"Rasters.jl","title":"Rasters.mappedcrs","text":"mappedcrs(x)\n\nGet the mapped coordinate reference system for the Y/X dims of an array.\n\nIn Projected lookup this is used to convert Selector values form the mappedcrs defined projection to the underlying projection, and to show plot axes in the mapped projection.\n\nIn Mapped lookup this is the coordinate reference system of the index values. See setmappedcrs to set it manually.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedbounds","page":"Rasters.jl","title":"Rasters.mappedbounds","text":"mappedbounds(x)\n\nGet the bounds converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular bounds.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mappedindex","page":"Rasters.jl","title":"Rasters.mappedindex","text":"mappedindex(x)\n\nGet the index value of a dimension converted to the mappedcrs value.\n\nWhithout ArchGDAL loaded, this is just the regular dim value.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mask","page":"Rasters.jl","title":"Rasters.mask","text":"mask(A:AbstractRaster; with, missingval=missingval(A))\nmask(x; with)\n\nReturn a new array with values of A masked by the missing values of with, or by the shape of with, if with is a geometric object.\n\nArguments\n\nx: a Raster or RasterStack\n\nKeywords\n\nwith: an AbstractRaster, or any GeoInterface.jl compatible objects   or table. The coordinate reference system of the point must match crs(A).\nmissingval: the missing value to use in the returned file.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nGeometry keywords\n\nThese can be used when with is a GeoInterface.jl compatible object:\n\nshape: Force data to be treated as :polygon, :line or :point geometries.   using points or lines as polygons may have unexpected results.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the polygon :touches the pixel, or that are completely :inside the polygon.   The default is :center.\n\nExample\n\nMask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask.\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates\n\n# Load and plot the file\nawap = read(Raster(AWAP, :tmax; date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45))\n\n# Create a mask my resampling a worldclim file\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask\nawap_masked = mask(awap; with=wc_mask)\nb = plot(awap_masked; clims=(10, 45))\n\nsavefig(a, \"build/mask_example_before.png\");\nsavefig(b, \"build/mask_example_after.png\"); nothing\n# output\n\n\nBefore mask:\n\n(Image: before mask)\n\nAfter mask:\n\n(Image: after mask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mask!","page":"Rasters.jl","title":"Rasters.mask!","text":"mask!(x; with, missingval=missingval(A))\n\nMask A by the missing values of with, or by all values outside with if it is a polygon.\n\nIf with is a polygon, creates a new array where points falling outside the polygon have been replaced by missingval(A).\n\nReturn a new array with values of A masked by the missing values of with, or by a polygon.\n\nArguments\n\nx: a Raster or RasterStack.\n\nKeywords\n\nwith: another AbstractRaster, a AbstractVector of Tuple points,   or any GeoInterface.jl AbstractGeometry. The coordinate reference system   of the point must match crs(A).\nmissingval: the missing value to write to A in masked areas,   by default missingval(A).\n\nExample\n\nMask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask to match the size and projection.\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates\n\n# Load and plot the file\nawap = read(RasterStack(AWAP, (:tmin, :tmax); date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45), c=:imola)\n\n# Create a mask my resampling a worldclim file\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask\nmask!(awap; with=wc_mask)\nb = plot(awap; clims=(10, 45))\n\nsavefig(a, \"build/mask_bang_example_before.png\");\nsavefig(b, \"build/mask_bang_example_after.png\"); nothing\n\n# output\n\n\nBefore mask!:\n\n(Image: before mask!)\n\nAfter mask!:\n\n(Image: after mask!)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.missingval","page":"Rasters.jl","title":"Rasters.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.missingmask","page":"Rasters.jl","title":"Rasters.missingmask","text":"missingmask(obj::Raster; kw...)\nmissingmask(obj; [to, res, size, collapse])\n\nCreate a mask array of missing and true values, from another Raster. AbstractRasterStack or AbstractRasterSeries are also accepted, but a mask is taken of the first layer or object not all of them.\n\nFor AbstractRaster the default missingval is missingval(A), but others can be chosen manually.\n\nThe array returned from calling missingmask on a AbstractRaster is a Raster with the same size and fields as the original array.\n\nKeywords\n\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from the geometries,   Additionally, when no to object or an Extent is passed for to, the size   or res keyword must also be used.\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\ncrs: a crs which will be attached to the resulting raster when to not passed  or is an Extent. Otherwise the crs from to is used.\nshape: Force data to be treated as :polygon, :line or :point geometries.   using points or lines as polygons may have unexpected results.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the polygon :touches the pixel, or that are completely :inside the polygon.   The default is :center.\n\nExample\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nmissingmask(wc) |> plot\n\nsavefig(\"build/missingmask_example.png\"); nothing\n\n# output\n\n(Image: missingmask)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mosaic","page":"Rasters.jl","title":"Rasters.mosaic","text":"mosaic(f, regions...; missingval, atol)\nmosaic(f, regions; missingval, atol)\n\nCombine regions into a single raster.\n\nArguments\n\nf: A reducing function (mean, sum, first, last etc.)   for values where regions overlap.\nregions: Iterable or splatted Raster or RasterStack.\n\nKeywords\n\nmissingval: Fills empty areas, and defualts to the   missingval of the first region.\natol: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nIf your mosaic has has apparent line errors, increase the atol value.\n\nExample\n\nHere we cut out Australia and Africa from a stack, and join them with mosaic.\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots\nst = RasterStack(WorldClim{Climate}; month=1);\n\nafrica = st[X(-20.0 .. 60.0), Y(-40.0 .. 35.0)]\na = plot(africa)\n\naus = st[X(100.0 .. 160.0), Y(-50.0 .. -10.0)]\nb = plot(aus)\n\n# Combine with mosaic\nmos = mosaic(first, aus, africa)\nc = plot(mos)\n\nsavefig(a, \"build/mosaic_example_africa.png\")\nsavefig(b, \"build/mosaic_example_aus.png\")\nsavefig(c, \"build/mosaic_example_combined.png\")\nnothing\n# output\n\n\nIndividual continents\n\n(Image: arica)\n\n(Image: aus)\n\nMosaic of continents\n\n(Image: mosaic)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.mosaic!","page":"Rasters.jl","title":"Rasters.mosaic!","text":"mosaic!(f, x, regions...; missingval, atol)\nmosaic!(f, x, regions::Tuple; missingval, atol)\n\nCombine regions in x using the function f.\n\nArguments\n\nf a function (e.g. mean, sum, first or last) that is applied to   values where regions overlap.\nx: A Raster or RasterStack. May be a an opened disk-based Raster,   the result will be written to disk.   With the current algorithm, the read speed is slow.\nregions: source objects to be joined. These should be memory-backed   (use read first), or may experience poor performance. If all objects have   the same extent, mosaic is simply a merge.\n\nKeywords\n\nmissingval: Fills empty areas, and defualts to the `missingval/   of the first layer.\natol: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.\n\nExample\n\nCut out Australia and Africa stacks, then combined them into a single stack.\n\nusing Rasters, RasterDataSources, ArchGDAL, Statistics, Plots\nst = read(RasterStack(WorldClim{Climate}; month=1))\naus = st[X=100.0 .. 160.0, Y=-50.0 .. -10.0]\nafrica = st[X=-20.0 .. 60.0, Y=-40.0 .. 35.0]\nmosaic!(first, st, aus, africa)\nplot(st)\nsavefig(\"build/mosaic_bang_example.png\")\nnothing\n# output\n\n\n(Image: mosaic)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.points","page":"Rasters.jl","title":"Rasters.points","text":"points(A::AbstractRaster; dims=(YDim, XDim), ignore_missing) => Array{Tuple}\n\nReturns a generator of the points in A for dimensions in dims, where points are a tuple of the values in each specified dimension index.\n\nKeywords\n\ndims the dimensions to return points from. The first slice of other   layers will be used.\nignore_missing: wether to ignore missing values in the array when considering   points. If true, all points in the dimensions will be returned, if false   only the points that are not === missingval(A) will be returned.\n\nThe order of dims determines the order of the points.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.rasterize","page":"Rasters.jl","title":"Rasters.rasterize","text":"rasterize([reducer], data; kw...)\n\nRasterize a GeoInterface.jl compatable geometry or feature, or a Tables.jl table with a :geometry column of GeoInterface.jl objects, or X, Y points columns.\n\nArguments\n\nreducer: a reducing function to reduce the fill value for all geometries that   cover or touch a pixel down to a single value. The default is last.   Any  that takes an iterable and returns a single value will work, including   custom functions. However, there are optimisations for built-in methods   including sum, first, last, minimum, maximum, extrema and Statistics.mean.   These may be an order of magnitude or more faster than   count is a special-cased as it does not need a fill value.\ndata: a GeoInterface.jl AbstractGeometry, or a nested Vector of AbstractGeometry,   or a Tables.jl compatible object containing a :geometry column or points and values columns.\n\nKeywords\n\nThese are detected automatically from data where possible.\n\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from the geometries,   Additionally, when no to object or an Extent is passed for to, the size   or res keyword must also be used.\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\ncrs: a crs which will be attached to the resulting raster when to not passed  or is an Extent. Otherwise the crs from to is used.\nshape: Force data to be treated as :polygon, :line or :point geometries.   using points or lines as polygons may have unexpected results.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the polygon :touches the pixel, or that are completely :inside the polygon.   The default is :center.\n\nfill: the value or values to fill a polygon with. A Symbol or tuple of Symbol will   be used to retrieve properties from features or column values from table rows. An array   or other iterable will be used for each geometry, in order. fill can also be a function of    the current value, e.g. x -> x + 1.\nop: A reducing function that accepts two values and returns one, like min to minimum.   For common methods this will be assigned for you, or is not required. But you can use it   instead of a reducer as it will usually be faster.\nshape: force data to be treated as :polygon, :line or :point, where possible   Points can't be treated as lines or polygons, and lines may not work as polygons, but   an attempt will be made.\ngeometrycolumn: Symbol to manually select the column the geometries are in   when data is a Tables.jl compatible table, or a tuple of Symbol for columns of   point coordinates.\nprogress: show a progress bar, true by default, false to hide..\nverbose: print information and warnings whne there are problems with the rasterisation.   true by default.\nthreaded: run operations in parallel. true by default.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nExample\n\nRasterize a shapefile for China and plot, with a border.\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates, Shapefile, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"country_borders.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Load the shapes for china\nchina_border = Shapefile.Handle(shapefile_name).shapes[10]\n\n# Rasterize the border polygon\nchina = rasterize(last, china_border; res=0.1, missingval=0, fill=1, boundary=:touches, progress=false)\n\n# And plot\np = plot(china; color=:spring, legend=false)\nplot!(p, china_border; fillalpha=0, linewidth=0.6)\n\nsavefig(\"build/china_rasterized.png\"); nothing\n\n# output\n\n\n(Image: rasterize)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.rasterize!","page":"Rasters.jl","title":"Rasters.rasterize!","text":"rasterize!([reducer], dest, data; kw...)\n\nRasterize the geometries in data into the Raster or RasterStack dest, using the values specified by fill.\n\nArguments\n\ndest: a Raster or RasterStack to rasterize into.\nreducer: a reducing function to reduce the fill value for all geometries that   cover or touch a pixel down to a single value. The default is last.   Any  that takes an iterable and returns a single value will work, including   custom functions. However, there are optimisations for built-in methods   including sum, first, last, minimum, maximum, extrema and Statistics.mean.   These may be an order of magnitude or more faster than   count is a special-cased as it does not need a fill value.\ndata: a GeoInterface.jl AbstractGeometry, or a nested Vector of AbstractGeometry,   or a Tables.jl compatible object containing a :geometry column or points and values columns.\n\nKeywords\n\nThese are detected automatically from A and data where possible.\n\nfill: the value or values to fill a polygon with. A Symbol or tuple of Symbol will   be used to retrieve properties from features or column values from table rows. An array   or other iterable will be used for each geometry, in order. fill can also be a function of    the current value, e.g. x -> x + 1.\nop: A reducing function that accepts two values and returns one, like min to minimum.   For common methods this will be assigned for you, or is not required. But you can use it   instead of a reducer as it will usually be faster.\nshape: force data to be treated as :polygon, :line or :point, where possible   Points can't be treated as lines or polygons, and lines may not work as polygons, but   an attempt will be made.\ngeometrycolumn: Symbol to manually select the column the geometries are in   when data is a Tables.jl compatible table, or a tuple of Symbol for columns of   point coordinates.\nprogress: show a progress bar, true by default, false to hide..\nverbose: print information and warnings whne there are problems with the rasterisation.   true by default.\nthreaded: run operations in parallel. true by default.\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from the geometries,   Additionally, when no to object or an Extent is passed for to, the size   or res keyword must also be used.\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\ncrs: a crs which will be attached to the resulting raster when to not passed  or is an Extent. Otherwise the crs from to is used.\nshape: Force data to be treated as :polygon, :line or :point geometries.   using points or lines as polygons may have unexpected results.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the polygon :touches the pixel, or that are completely :inside the polygon.   The default is :center.\n\nExample\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots, Dates, Shapefile, GeoInterface, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"country_borders.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Load the shapes for indonesia\nindonesia_border = Shapefile.Handle(shapefile_name).shapes[1]\n\n# Make an empty EPSG 4326 projected Raster of the area of Indonesia\ndimz = X(Projected(90.0:0.1:145; sampling=Intervals(), crs=EPSG(4326))),\n       Y(Projected(-15.0:0.1:10.9; sampling=Intervals(), crs=EPSG(4326)))\n\nA = zeros(UInt32, dimz; missingval=UInt32(0))\n\n# Rasterize each indonesian island with a different number. The islands are\n# rings of a multi-polygon, so we use `GI.getring` to get them all separately.\nislands = collect(GeoInterface.getring(indonesia_border))\nrasterize!(last, A, islands; fill=1:length(islands), progress=false)\n\n# And plot\np = plot(Rasters.trim(A); color=:spring)\nplot!(p, indonesia_border; fillalpha=0, linewidth=0.7)\n\nsavefig(\"build/indonesia_rasterized.png\"); nothing\n\n# output\n\n\n(Image: rasterize)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.resample","page":"Rasters.jl","title":"Rasters.resample","text":"resample(x; kw...)\nresample(xs...; to=first(xs), kw...)\n\nresample uses ArchGDAL.gdalwarp to resample a Raster or RasterStack to a new resolution and optionally new crs, or to snap to the bounds, resolution and crs of the object to.\n\nArguments\n\nx: the object/s to resample.\n\nKeywords\n\nto: a Raster, RasterStack, Tuple of Dimension or Extents.Extent.   If no to object is provided the extent will be calculated from x,\nres: the resolution of the dimensions, a Real or Tuple{<:Real,<:Real}.   Only required when to is not used or is an Extents.Extent, and size is not used.\nsize: the size of the output array, as a Tuple{Int,Int} or single Int for a square.   Only required when to is not used or is an Extents.Extent, and res is not used.\ncrs: a crs which will be attached to the resulting raster when to not passed  or is an Extent. Otherwise the crs from to is used.\nmethod: A Symbol or String specifying the method to use for resampling.   From the docs for gdalwarp:\n:near: nearest neighbour resampling (default, fastest algorithm, worst interpolation quality).\n:bilinear: bilinear resampling.\n:cubic: cubic resampling.\n:cubicspline: cubic spline resampling.\n:lanczos: Lanczos windowed sinc resampling.\n:average: average resampling, computes the weighted average of all non-NODATA contributing pixels.   rms root mean square / quadratic mean of all non-NODATA contributing pixels (GDAL >= 3.3)\n:mode: mode resampling, selects the value which appears most often of all the sampled points.\n:max: maximum resampling, selects the maximum value from all non-NODATA contributing pixels.\n:min: minimum resampling, selects the minimum value from all non-NODATA contributing pixels.\n:med: median resampling, selects the median value of all non-NODATA contributing pixels.\n:q1: first quartile resampling, selects the first quartile value of all non-NODATA contributing pixels.\n:q3: third quartile resampling, selects the third quartile value of all non-NODATA contributing pixels.\n:sum: compute the weighted sum of all non-NODATA contributing pixels (since GDAL 3.1)\nWhere NODATA values are set to missingval.\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nNote:\n\nGDAL may cause some unexpected changes in the data, such as returning a reversed Y dimension or changing the crs type from EPSG to WellKnownText (it will represent the same CRS).\n\nExample\n\nResample a WorldClim layer to match an EarthEnv layer:\n\nusing Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{Climate}, :prec; month=1)\nB = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\n\na = plot(A)\nb = plot(resample(A; to=B))\n\nsavefig(a, \"build/resample_example_before.png\");\nsavefig(b, \"build/resample_example_after.png\"); nothing\n# output\n\nBefore resample:\n\n(Image: before resample)\n\nAfter resample:\n\n(Image: after resample)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.replace_missing","page":"Rasters.jl","title":"Rasters.replace_missing","text":"replace_missing(a::AbstractRaster, newmissingval)\nreplace_missing(a::AbstractRasterStack, newmissingval)\n\nReplace missing values in the array or stack with a new missing value, also updating the missingval field/s.\n\nKeywords\n\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nExample\n\nusing Rasters, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{Climate}, :prec; month=1) |> replace_missing\nmissingval(A)\n# output\nmissing\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.reproject","page":"Rasters.jl","title":"Rasters.reproject","text":"reproject(target::GeoFormat, x)\n\nReproject the dimensions of x to a different crs.\n\nArguments\n\ntarget: any crs in a GeoFormatTypes.jl wrapper, e.g. EPSG, WellKnownText, ProjString.\nx: a Dimension, Tuple of Dimension, Raster or RasterStack.\n\nDimensions without an AbstractProjected lookup (such as a Ti dimension) are silently returned without modification.\n\n\n\n\n\nreproject(source::GeoFormat, target::GeoFormat, dim::Dimension, val)\n\nreproject uses ArchGDAL.reproject, but implemented for a reprojecting a value array of values, a single dimension at a time.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.setcrs","page":"Rasters.jl","title":"Rasters.setcrs","text":"setcrs(x, crs)\n\nSet the crs of a Raster, RasterStack, Tuple of Dimension, or a Dimension. The crs is expected to be a GeoFormatTypes.jl CRS or Mixed GeoFormat type\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.setmappedcrs","page":"Rasters.jl","title":"Rasters.setmappedcrs","text":"setmappedcrs(x, crs)\n\nSet the mapped crs of a Raster, a RasterStack, a Tuple of Dimension, or a Dimension. The crs is expected to be a GeoFormatTypes.jl CRS or Mixed GeoFormat type\n\n\n\n\n\n","category":"function"},{"location":"#Base.skipmissing","page":"Rasters.jl","title":"Base.skipmissing","text":"skipmissing(itr::Raster)\n\nReturns an iterable over the elements in a Raster object, skipping any values equal to either the missingval or missing.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.trim","page":"Rasters.jl","title":"Rasters.trim","text":"trim(x; dims::Tuple, pad::Int)\n\nTrim missingval(x) from x for axes in dims, returning a view of x.\n\nArguments\n\nx: A Raster or RasterStack. For stacks, all layers must having   missing values for a pixel for it to be trimmed.\n\nKeywords\n\ndims: By default dims=(XDim, YDim), so that trimming keeps the area    of X and Y that contains non-missing values along all other dimensions.\npad: The trimmed size will be padded by pad on all sides, although   padding will not be added beyond the original extent of the array.\n\nAs trim is lazy, filename and suffix keywords are not used.\n\nExample\n\nCreate trimmed layers of Australian habitat heterogeneity.\n\nusing Rasters, RasterDataSources, Plots\nlayers = (:evenness, :range, :contrast, :correlation)\nst = RasterStack(EarthEnv{HabitatHeterogeneity}, layers)\n\n# Roughly cut out australia\nausbounds = X(100 .. 160), Y(-50 .. -10)\naus = st[ausbounds...]\na = plot(aus)\n\n# Trim missing values and plot\nb = plot(trim(aus))\n\nsavefig(a, \"build/trim_example_before.png\");\nsavefig(b, \"build/trim_example_after.png\"); nothing\n\n# output\n\n\nBefore trim:\n\n(Image: before trim)\n\nAfter trim:\n\n(Image: after trim)\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.warp","page":"Rasters.jl","title":"Rasters.warp","text":"warp(A::AbstractRaster, flags::Dict; kw...)\n\nGives access to the GDALs gdalwarp method given a Dict of  flag => value arguments that can be converted to strings, or vectors where multiple space-separated arguments are required.\n\nArrays with additional dimensions not handled by GDAL (other than X, Y, Band) are sliced, warped, and then combined to match the original array dimensions.  These slices will not be written to disk and loaded lazyily at this stage - you will need to do that manually if required.\n\nSee the gdalwarp docs for a list of arguments.\n\nKeywords\n\nfilename: a filename to write to directly, useful for large files.\nsuffix: a string or value to append to the filename.   A tuple of suffix will be applied to stack layers. keys(stack) are the default.\n\nAny additional keywords are passed to ArchGDAL.Dataset.\n\nExample\n\nThis simply resamples the array with the :tr (output file resolution) and :r flags, giving us a pixelated version:\n\nusing Rasters, RasterDataSources, Plots\nA = Raster(WorldClim{Climate}, :prec; month=1)\na = plot(A)\n\nflags = Dict(\n    :tr => [2.0, 2.0],\n    :r => :near,\n)\nb = plot(warp(A, flags))\n\nsavefig(a, \"build/warp_example_before.png\");\nsavefig(b, \"build/warp_example_after.png\"); nothing\n\n# output\n\n\nBefore warp:\n\n(Image: before warp)\n\nAfter warp:\n\n(Image: after warp)\n\nIn practise, prefer resample for this. But warp may be more flexible.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.zonal","page":"Rasters.jl","title":"Rasters.zonal","text":"zonal(f, x::Union{Raster,RasterStack}; of, kw...)\n\nCalculate zonal statistics for the the zone of a Raster or RasterStack covered by the of object/s.\n\nArguments\n\nf: any function that reduces an iterable to a single value, such as sum or Statistics.mean\nx: A Raster or RasterStack\nof: A Raster, RasterStack, dim tuple, extent, GeoInterface.jl compatible geometry,   Tables.jl compatible table of a :geometry column, or an AbstractVector of   any of these objects..\n\nKeywords\n\nThese can be used when of is a GeoInterface.jl compatible object:\n\nshape: Force data to be treated as :polygon, :line or :point, where possible.\nboundary: for polygons, include pixels where the :center is inside the polygon,   where the line :touches the pixel, or that are completely :inside inside the polygon.   The default is :center.\nprogress: show a progress bar, true by default, false to hide..\n\nExample\n\n``jldoctest using Rasters, RasterDataSources, ArchGDAL, Shapefile, DataFrames, Downloads, Statistics, Dates\n\nDownload a borders shapefile\n\nneurl = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10mcultural/ne10madmin0countries\" shpurl, dbfurl  = neurl * \".shp\", neurl * \".dbf\" shpname, dbfname = \"countryborders.shp\", \"countryborders.dbf\" isfile(shpname) || Downloads.download(shpurl, shpname) isfile(dbfurl) || Downloads.download(dbfurl, dbfname)\n\nDownload and read a raster stack from WorldClim\n\nst = RasterStack(WorldClim{Climate}; month=Jan, lazy=false)\n\nLoad the shapes for world countries\n\ncountries = Shapefile.Table(shp_name) |> DataFrame\n\nCalculate the january mean of all climate variables for all countries\n\njanuary_stats = zonal(mean, st; of=countries, boundary=:touches, progress=false) |> DataFrame\n\nAdd the country name column (natural earth has some string errors it seems)\n\ninsertcols!(january_stats, 1, :country => first.(split.(countries.ADMIN, r\"[^A-Za-z ]\")))\n\noutput\n\n258×8 DataFrame  Row │ country                       tmin       tmax       tavg       prec     ⋯      │ SubStrin…                     Float32    Float32    Float32    Float64  ⋯ ─────┼──────────────────────────────────────────────────────────────────────────    1 │ Indonesia                      21.5447    29.1864    25.3656   271.063  ⋯    2 │ Malaysia                       21.3087    28.4291    24.8688   273.381    3 │ Chile                           7.24534   17.9263    12.5858    78.1287    4 │ Bolivia                        17.2065    27.7454    22.4759   192.542    5 │ Peru                           15.0273    25.5504    20.2888   180.007  ⋯    6 │ Argentina                      13.6751    27.6715    20.6732    67.1837    7 │ Dhekelia Sovereign Base Area    5.87126   15.8991    10.8868    76.25    8 │ Cyprus                          5.65921   14.6665    10.1622    97.4474   ⋮  │              ⋮                    ⋮          ⋮          ⋮         ⋮     ⋱  252 │ Spratly Islands                25.0       29.2       27.05      70.5    ⋯  253 │ Clipperton Island              21.5       33.2727    27.4        6.0  254 │ Macao S                        11.6694    17.7288    14.6988    28.0  255 │ Ashmore and Cartier Islands   NaN        NaN        NaN        NaN  256 │ Bajo Nuevo Bank               NaN        NaN        NaN        NaN      ⋯  257 │ Serranilla Bank               NaN        NaN        NaN        NaN  258 │ Scarborough Reef              NaN        NaN        NaN        NaN                                                   3 columns and 243 rows omitted ```\n\n\n\n\n\n","category":"function"},{"location":"#Slice-and-combine-to-and-from-RasterSeries","page":"Rasters.jl","title":"Slice and combine to and from RasterSeries","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"slice\ncombine","category":"page"},{"location":"#Rasters.slice","page":"Rasters.jl","title":"Rasters.slice","text":"slice(A::Union{AbstractRaster,AbstractRasterStack,AbstracRasterSeries}, dims) => RasterSeries\n\nSlice views along some dimension/s to obtain a RasterSeries of the slices.\n\nFor a Raster or RasterStack this will return a RasterSeries of Raster or RasterStack that are slices along the specified dimensions.\n\nFor a RasterSeries, the output is another series where the child objects are sliced and the series dimensions index is now of the child dimensions combined. slice on a RasterSeries with no dimensions will slice along the dimensions shared by both the series and child object.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#Rasters.combine","page":"Rasters.jl","title":"Rasters.combine","text":"combine(A::Union{AbstractRaster,AbstractRasterStack,AbstracRasterSeries}, [dims]) => Raster\n\nCombine a RasterSeries along some dimension/s, creating a new Raster or RasterStack, depending on the contents of the series.\n\nIf dims are passed, only the specified dimensions will be combined with a RasterSeries returned, unless dims is all the dims in the series.\n\nWARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.\n\n\n\n\n\n","category":"function"},{"location":"#File-operations","page":"Rasters.jl","title":"File operations","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"These Base and DimensionalData methods have specific Rasters.jl versions:","category":"page"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"modify\nopen\nread\nread!\nwrite","category":"page"},{"location":"#DimensionalData.modify","page":"Rasters.jl","title":"DimensionalData.modify","text":"modify(f, series::AbstractRasterSeries)\n\nApply function f to the data of the child object. If the child is an AbstractRasterStack the function will be passed on to its child AbstractRasters.\n\nf must return an idenically sized array.\n\nThis method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.\n\nAn example of the usefulnesss of this is for swapping out array backend for an entire series to CuArray from CUDA.jl to copy data to a GPU.\n\n\n\n\n\n","category":"function"},{"location":"#Base.open","page":"Rasters.jl","title":"Base.open","text":"open(f, A::AbstractRaster; write=false)\n\nopen is used to open any lazy=true AbstractRaster and do multiple operations on it in a safe way. The write keyword opens the file in write lookup so that it can be altered on disk using e.g. a broadcast.\n\nf is a method that accepts a single argument - an Raster object which is just an AbstractRaster that holds an open disk-based object. Often it will be a do block:\n\nlazy=false (in-memory) rasters will ignore open and pass themselves to f.\n\n# A is an `Raster` wrapping the opened disk-based object.\nopen(Raster(filepath); write=true) do A\n    mask!(A; with=maskfile)\n    A[I...] .*= 2\n    # ...  other things you need to do with the open file\nend\n\nBy using a do block to open files we ensure they are always closed again after we finish working with them.\n\n\n\n\n\n","category":"function"},{"location":"#Base.read","page":"Rasters.jl","title":"Base.read","text":"read(A::AbstractRaster)\nread(A::AbstractRasterStack)\nread(A::AbstractRasterSeries)\n\nread will move a Rasters.jl object completely to memory.\n\n\n\n\n\n","category":"function"},{"location":"#Base.read!","page":"Rasters.jl","title":"Base.read!","text":"read!(src::Union{AbstractString,AbstractRaster}, dst::AbstractRaster)\nread!(src::Union{AbstractString,AbstractRasterStack}, dst::AbstractRasterStack)\nread!(scr::AbstractRasterSeries, dst::AbstractRasterSeries)\n\nread! will copy the data from src to the object dst. \n\nsrc can be an object or a file-path String.\n\n\n\n\n\n","category":"function"},{"location":"#Base.write","page":"Rasters.jl","title":"Base.write","text":"Base.write(filename::AbstractString, A::AbstractRaster; kw...)\n\nWrite an AbstractRaster to file, guessing the backend from the file extension.\n\nKeyword arguments are passed to the write method for the backend.\n\n\n\n\n\nBase.write(filename::AbstractString, s::AbstractRasterStack; suffix, kw...)\n\nWrite any AbstractRasterStack to file, guessing the backend from the file extension.\n\nKeywords\n\nsuffix: suffix to append to file names. By default the layer key is used.\n\nOther keyword arguments are passed to the write method for the backend.\n\nIf the source can't be saved as a stack-like object, individual array layers will be saved.\n\n\n\n\n\nBase.write(filepath::AbstractString, s::AbstractRasterSeries; kw...)\n\nWrite any AbstractRasterSeries to file, guessing the backend from the file extension.\n\nThe lookup values of the series will be appended to the filepath (before the extension), separated by underscores.\n\nKeywords\n\nSee other docs for write. All keywords are passed through to Raster and RasterStack methods.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GRDsource}, s::AbstractRaster; force=false)\n\nWrite a Raster to a .grd file with a .gri header file.  The extension of filename will be ignored.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDsource}, A::AbstractRaster)\n\nWrite an NCDarray to a NetCDF file using NCDatasets.jl\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDsource}, s::AbstractRasterStack; kw...)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently Metadata is not handled for dimensions, and Metadata from other AbstractRaster @types is ignored.\n\nKeywords\n\nKeywords are passed to NCDatasets.defVar.\n\nappend: If true, the variable of the current Raster will be appended to   filename. Note that the variable of the current Raster should be not exist   before. If not, you need to set append = false. Rasters.jl can not   overwrite a previous existing variable.\nfillvalue: A value filled in the NetCDF file to indicate missing data. It   will be stored in the _FillValue attribute.\nchunksizes: Vector integers setting the chunk size. The total size of a   chunk must be less than 4 GiB.\ndeflatelevel: Compression level: 0 (default) means no compression and 9   means maximum compression. Each chunk will be compressed individually.\nshuffle: If true, the shuffle filter is activated which can improve the   compression ratio.\nchecksum: The checksum method can be :fletcher32 or :nochecksum   (checksumming is disabled, which is the default)\ntypename (string): The name of the NetCDF type required for vlen arrays   (https://web.archive.org/save/https://www.unidata.ucar.edu/software/netcdf/netcdf-4/newdocs/netcdf-c/nc005fdef005fvlen.html)\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GDALsource}, A::AbstractRaster; force=false, kw...)\n\nWrite a Raster to file using GDAL.\n\nKeywords\n\ndriver: A GDAL driver name or a GDAL driver retrieved via ArchGDAL.getdriver(drivername). Guessed from the filename extension by default.\noptions::Dict{String,String}: A dictionary containing the dataset creation options passed to the driver. For example: Dict(\"COMPRESS\"=>\"DEFLATE\")\nValid options for the drivers can be looked up here: https://gdal.org/drivers/raster/index.html\n\nReturns filename.\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Rasters.jl","title":"Internals","text":"","category":"section"},{"location":"","page":"Rasters.jl","title":"Rasters.jl","text":"Rasters.FileArray\nRasters.FileStack\nRasters.OpenStack\nRasters.RasterDiskArray","category":"page"},{"location":"#Rasters.FileArray","page":"Rasters.jl","title":"Rasters.FileArray","text":"FileArray{X} <: DiskArrays.AbstractDiskArray\n\nFilearray is a DiskArrays.jl AbstractDiskArray. Instead of holding an open object, it just holds a filename string that is opened lazily  when it needs to be read.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.FileStack","page":"Rasters.jl","title":"Rasters.FileStack","text":"FileStack{X,K}\n\nFileStack{X,K}(filename, types, sizes, eachchunk, haschunks, write)\n\nA wrapper object that holds file pointer and size/chunking metadata for a multi-layered stack stored in a single file,  typically netcdf or hdf5.\n\nX is a backend type like NCDsource, and K is a tuple of Symbol keys.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.OpenStack","page":"Rasters.jl","title":"Rasters.OpenStack","text":"OpenStack{X,K}\n\nOpenStack{X,K}(dataset)\n\nA wrapper for any stack-like opened dataset that can be indexed with Symbol keys to retrieve AbstractArray layers.\n\nOpenStack is usually hidden from users, wrapped in a regular RasterStack passed as the function argument in open(stack) when the stack is contained in a single file.\n\nX is a backend type like NCDsource, and K is a tuple of Symbol keys.\n\n\n\n\n\n","category":"type"},{"location":"#Rasters.RasterDiskArray","page":"Rasters.jl","title":"Rasters.RasterDiskArray","text":"RasterDiskArray <: DiskArrays.AbstractDiskArray\n\nA basic DiskArrays.jl wrapper for objects that don't have one defined yet.  When we open a FileArray it is replaced with a RasterDiskArray.\n\n\n\n\n\n","category":"type"}]
}
