{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#rastersjl","title":"Rasters.jl","text":"<p>Rasters.jl defines common types and methods for reading, writing and manipulating rasterized spatial data. </p> <p>These currently include raster arrays like <code>GeoTIFF</code> and <code>NetCDF</code>, <code>R grd</code> files,  multi-layered stacks, and multi-file series of arrays and stacks. </p> <p>Data-source abstraction</p> <p>Rasters provides a standardised interface that allows many source data types to be used with identical syntax.</p> <ul> <li>Scripts and packages building on Rasters.jl can treat <code>Raster</code>,</li> </ul> <p><code>RasterStack</code>, and <code>RasterSeries</code> as black boxes.</p> <ul> <li>The data could hold GeoTiff or NetCDF files, <code>Array</code>s in memory or   <code>CuArray</code>s on the GPU - they will all behave in the same way.</li> <li><code>RasterStack</code> can be backed by a Netcdf or HDF5 file, or a <code>NamedTuple</code> of   <code>Raster</code> holding <code>.tif</code> files, or all <code>Raster</code> in memory.</li> <li>Users do not have to deal with the specifics of spatial file types.</li> <li><code>Projected</code> lookups with Cylindrical projections can by indexed using other Cylindrical projections</li> </ul> <p>by setting the <code>mappedcrs</code> keyword on construction. You don't need to know the underlying projection, the conversion is handled automatically. This means lat/lon <code>EPSG(4326)</code> can be used seamlessly if you need that.</p> <p>Packages extensions and Rasters 0.8 and onwards</p> <p>On Julia 1.9 we can put additional packages in extensions, so the code only loads when you load a specific package. Rasters.jl was always intended to work like this, and its finally possible. This reduced package <code>using</code> time from many seconds to well under a second.</p> <p>But, it means you have to manually load packages you need for each backend or additional functionality.</p> <p>For example, to use the GDAL backend, and download files, you now need to do:</p> <pre><code>using Rasters, ArchGDAL, RasterDataSources\n</code></pre> <p>where previously it was just using Rasters.</p> <p>Sources and packages needed:</p> <ul> <li>:gdal: <code>using ArchGDAL</code></li> <li>:netcdf: <code>using NCDatasets</code></li> <li>:grd: built-in.</li> <li>:smap: <code>using HDF5</code></li> <li>:grib: not yet finished.</li> </ul> <p>Other functionality in extensions:</p> <ul> <li>Raster data downloads, like Worldclim{Climate}: <code>using RasterDataSources</code></li> <li>Makie plots: <code>using Makie</code></li> <li>Coordinate transformations for gdal rasters: <code>using CoordinateTransformations</code></li> </ul> Bugs, errors and making issues for Rasters.jl <p>Raster data is complicated and there are many places for subtle or not-so-subtle bugs to creep in.</p> <p>We need bug reports to reduce how often they occur over time. But also, we need issues that are easy to reproduce or it isn't practically possible to fix them.</p> <p>Because there are so many raster file types and variations of them, most of the time we need the exact file that caused your problem to know how to fix it, and be sure that we have actually fixed it when we are done. So fixing a Rasters.jl bug nearly always involves downloading some file and running some code that breaks with it (if you can trigger the bug without a file, thats great! but its not always possible).</p> <p>To make an issue we can fix quickly (or at all) there are three key steps:</p> <ol> <li>Include the file in an accessible place on web without autentication or any other work on our part, so we can just get it and find your bug. You can put it on a file hosting platform (e.g. google drive, drop box, whatever you use) and share the url.</li> <li>Add a minimum working example to the issue template that first downloads the file, then runs the function that triggers the bug.</li> <li>Paste the complete stack trace of the error it produces, right to the bottom, into the issue template. Then we can be sure we reproduced the same problem.</li> </ol> <p>Good issues are really appreciated, but they do take just a little extra effort with Rasters.jl because of this need for files.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#index","title":"Index","text":"<ul> <li><code>Rasters.Rasters</code></li> <li><code>Rasters.AbstractProjected</code></li> <li><code>Rasters.AbstractRaster</code></li> <li><code>Rasters.AbstractRasterSeries</code></li> <li><code>Rasters.AbstractRasterStack</code></li> <li><code>Rasters.Band</code></li> <li><code>Rasters.FileArray</code></li> <li><code>Rasters.FileStack</code></li> <li><code>Rasters.Mapped</code></li> <li><code>Rasters.OpenStack</code></li> <li><code>Rasters.Projected</code></li> <li><code>Rasters.Raster</code></li> <li><code>Rasters.RasterDiskArray</code></li> <li><code>Rasters.RasterSeries</code></li> <li><code>Rasters.RasterStack</code></li> <li><code>Rasters.aggregate</code></li> <li><code>Rasters.aggregate!</code></li> <li><code>Rasters.boolmask</code></li> <li><code>Rasters.classify</code></li> <li><code>Rasters.classify!</code></li> <li><code>Rasters.combine</code></li> <li><code>Rasters.convertlookup</code></li> <li><code>Rasters.coverage</code></li> <li><code>Rasters.coverage!</code></li> <li><code>Rasters.crop</code></li> <li><code>Rasters.crs</code></li> <li><code>Rasters.disaggregate</code></li> <li><code>Rasters.disaggregate!</code></li> <li><code>Rasters.extend</code></li> <li><code>Rasters.extract</code></li> <li><code>Rasters.mappedbounds</code></li> <li><code>Rasters.mappedcrs</code></li> <li><code>Rasters.mappedindex</code></li> <li><code>Rasters.mask</code></li> <li><code>Rasters.mask!</code></li> <li><code>Rasters.missingmask</code></li> <li><code>Rasters.missingval</code></li> <li><code>Rasters.mosaic</code></li> <li><code>Rasters.mosaic!</code></li> <li><code>Rasters.points</code></li> <li><code>Rasters.rasterize</code></li> <li><code>Rasters.rasterize!</code></li> <li><code>Rasters.replace_missing</code></li> <li><code>Rasters.reproject</code></li> <li><code>Rasters.reproject</code></li> <li><code>Rasters.rplot</code></li> <li><code>Rasters.setcrs</code></li> <li><code>Rasters.setmappedcrs</code></li> <li><code>Rasters.slice</code></li> <li><code>Rasters.smapseries</code></li> <li><code>Rasters.trim</code></li> <li><code>Rasters.zonal</code></li> </ul>"},{"location":"reference/#reference-exported-functions","title":"Reference - Exported functions","text":"<p># <code>Rasters.Rasters</code> \u2014 Module.</p> <p>Rasters</p> <p> </p> <p></p> <p>Rasters.jl defines common types and methods for reading, writing and manipulating rasterized spatial data. </p> <p>These currently include raster arrays like GeoTIFF and NetCDF, R grd files,  multi-layered stacks, and multi-file series of arrays and stacks. </p> <p>:warning: Packages extensions and Rasters 0.8 and onwards</p> <p>On Julia 1.9 we can put additional packages in extensions, so the code only loads when you load a specific package. Rasters.jl was always intended to work like this, and its finally possible. This reduced package <code>using</code> time from many seconds to well under a second.</p> <p>But, it means you have to manually load packages you need for each backend or additional functionality.</p> <p>For example, to use the GDAL backend, and download files, you now need to do:</p> <pre><code>using Rasters, ArchGDAL, RasterDataSources\n</code></pre> <p>where previously it was just <code>using Rasters</code>.</p> <p>Sources and packages needed:</p> <ul> <li><code>:gdal</code>: <code>using ArchGDAL</code></li> <li><code>:netcdf</code>: <code>using NCDatasets</code></li> <li><code>:grd</code>: built-in.</li> <li><code>:smap</code>: <code>using HDF5</code></li> <li><code>:grib</code>: not yet finished.</li> </ul> <p>Other functionality in extensions:</p> <ul> <li>Raster data downloads, like <code>Worldclim{Climate}</code>: <code>using RasterDataSources</code></li> <li>Makie plots: <code>using Makie</code></li> <li>Coordinate transformations for gdal rasters: <code>using CoordinateTransformations</code></li> </ul> <p>Quick start</p> <p>Install the package by typing:</p> <pre><code>]\nadd Rasters\n</code></pre> <pre><code>using Rasters\n</code></pre> <p>Using <code>Rasters</code> to read GeoTiff or NetCDF files will output something similar to the following toy examples. This is possible because Rasters.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like <code>X</code>, <code>Y</code> and <code>Ti</code> (time) and e.g. spatial coordinates.</p> <pre><code>using Rasters, Dates\nlon, lat = X(25:1:30), Y(25:1:30)\nti = Ti(DateTime(2001):Month(1):DateTime(2002))\nras = Raster(rand(lon, lat, ti)) # this generates random numbers with the dimensions given\n</code></pre> <pre><code>6\u00d76\u00d713 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2002-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")))\nmissingval: missing\nvalues: [:, :, 1]\n     25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n[and 12 more slices...]\n</code></pre> <p>Getting the <code>lookup</code> array from dimensions</p> <pre><code>lon = lookup(ras, X) # if X is longitude\nlat = lookup(ras, Y) # if Y is latitude\n</code></pre> <pre><code>Sampled{Int64} ForwardOrdered Regular Points\nwrapping: 25:1:30\n</code></pre> <p>Select by index</p> <p>Selecting a time slice by <code>index</code> is done via</p> <pre><code>ras[Ti(1)]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n</code></pre> <pre><code>ras[Ti=1]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n</code></pre> <p>or and interval of indices using the syntax <code>=a:b</code> or <code>(a:b)</code></p> <pre><code>ras[Ti(1:10)]\n</code></pre> <pre><code>6\u00d76\u00d710 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-10-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2001-10-01T00:00:00\")))\nmissingval: missing\nvalues: [:, :, 1]\n     25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n[and 9 more slices...]\n</code></pre> <p>Select by value</p> <pre><code>ras[Ti=At(DateTime(2001))]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))\nmissingval: missing\nvalues:      25         26          27          28         29          30\n 25   0.9063     0.427328    0.0320967   0.297023   0.0571002   0.891377\n 26   0.443494   0.867547    0.350546    0.150155   0.24565     0.711039\n 27   0.745673   0.0991336   0.930332    0.893537   0.805931    0.360583\n 28   0.512083   0.125287    0.959434    0.354868   0.337824    0.259563\n 29   0.253849   0.692209    0.774092    0.131798   0.823656    0.390013\n 30   0.334152   0.136551    0.183555    0.941133   0.450484    0.461862\n</code></pre> <p>More options are available, like  <code>Near</code>, <code>Contains</code> and <code>Where</code>. For more details go here.</p> <p>Dimensions can also be used in most <code>Base</code> and <code>Statistics</code> methods like <code>mean</code> and <code>reduce</code> where <code>dims</code> arguments are required. Much of the behaviour is covered in the DimensionalData docs.</p> <p>See the docs for more details and examples for Rasters.jl.</p> <p>Data-source abstraction</p> <p>Rasters provides a standardised interface that allows many source data types to be used with identical syntax.</p> <ul> <li> <p>Scripts and packages building on Rasters.jl can treat <code>Raster</code>, <code>RasterStack</code>, and <code>RasterSeries</code> as black boxes.</p> <ul> <li>The data could hold GeoTiff or NetCDF files, <code>Array</code>s in memory or <code>CuArray</code>s on the GPU - they will all behave in the same way.</li> <li><code>RasterStack</code> can be backed by a Netcdf or HDF5 file, or a <code>NamedTuple</code> of <code>Raster</code> holding <code>.tif</code> files, or all <code>Raster</code> in memory.</li> <li>Users do not have to deal with the specifics of spatial file types.</li> <li><code>Projected</code> lookups with Cylindrical projections can by indexed using other Cylindrical projections by setting the <code>mappedcrs</code> keyword on construction. You don't need to know the underlying projection, the conversion is handled automatically. This means lat/lon <code>EPSG(4326)</code> can be used seamlessly if you need that.</li> </ul> </li> </ul> <p>Bugs, errors and making issues for Rasters.jl</p> <p>Raster data is complicated and there are many places for subtle or not-so-subtle bugs to creep in.</p> <p>We need bug reports to reduce how often they occur over time. But also, we need issues that are easy to reproduce or it isn't practically possible to fix them.</p> <p>Because there are so many raster file types and variations of them, most of the time we need the exact file that caused your problem to know how to fix it, and be sure that we have actually fixed it when we are done. So fixing a Rasters.jl bug nearly always involves downloading some file and running some code that breaks with it (if you can trigger the bug without a file, thats great! but its not always possible).</p> <p>To make an issue we can fix quickly (or at all) there are three key steps:</p> <ol> <li>Include the file in an accessible place on web without autentication or any other work on our part, so we can just get it and find your bug. You can put it on a file hosting platform (e.g. google drive, drop box, whatever you use) and share the url.</li> <li>Add a minimum working example to the issue template that first downloads the file, then runs the function that triggers the bug.</li> <li>Paste the complete stack trace of the error it produces, right to the bottom, into the issue template. Then we can be sure we reproduced the same problem.</li> </ol> <p>Good issues are really appreciated, but they do take just a little extra effort with Rasters.jl because of this need for files.</p> <p>source</p> <p># <code>Rasters.AbstractRaster</code> \u2014 Type.</p> <pre><code>AbstractRaster &lt;: DimensionalData.AbstractDimArray\n</code></pre> <p>Abstract supertype for objects that wrap an array (or location of an array)  and metadata about its contents. It may be memory or hold a <code>FileArray</code>, which holds the filename, and is only opened when required.</p> <p><code>AbstractRaster</code>s inherit from <code>AbstractDimArray</code> from DimensionalData.jl. They can be indexed as regular Julia arrays or with DimensionalData.jl <code>Dimension</code>s. They will plot as a heatmap in Plots.jl with correct coordinates and labels, even after slicing with <code>getindex</code> or <code>view</code>. <code>getindex</code> on a <code>AbstractRaster</code> will always return a memory-backed <code>Raster</code>.</p> <p>source</p> <p># <code>Rasters.AbstractRasterSeries</code> \u2014 Type.</p> <pre><code>AbstractRasterSeries &lt;: DimensionalData.AbstractDimensionalArray\n</code></pre> <p>Abstract supertype for high-level <code>DimensionalArray</code> that hold <code>RasterStacks</code>, <code>Rasters</code>, or the paths they can be loaded from. <code>RasterSeries</code> are indexed with dimensions as with a <code>AbstractRaster</code>. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation.</p> <p>As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.</p> <p>This allows syntax like below for a series of stacks of arrays:</p> <pre><code>RasterSeries[Time(Near(DateTime(2001, 1))][:temp][Y(Between(70, 150)), X(Between(-20,20))] |&gt; plot`\n</code></pre> <p><code>RasterSeries</code> is the concrete implementation.</p> <p>source</p> <p># <code>Rasters.AbstractRasterStack</code> \u2014 Type.</p> <pre><code>AbstractRasterStack\n</code></pre> <p>Abstract supertype for objects that hold multiple <code>AbstractRaster</code>s that share spatial dimensions.</p> <p>They are <code>NamedTuple</code>-like structures that may either contain <code>NamedTuple</code> of <code>AbstractRaster</code>s, string paths that will load <code>AbstractRaster</code>s, or a single path that points to a file containing multiple layers, like NetCDF or HDF5. Use and syntax is similar or identical for all cases.</p> <p><code>AbstractRasterStack</code> can hold layers that share some or all of their dimensions. They cannot have the same dimension with different length or spatial extent as another layer.</p> <p><code>getindex</code> on an <code>AbstractRasterStack</code> generally returns a memory backed standard <code>Raster</code>. <code>raster[:somelayer] |&gt; plot</code> plots the layers array, while <code>raster[:somelayer, X(1:100), Band(2)] |&gt; plot</code> will plot the subset without loading the whole array.</p> <p><code>getindex</code> on an <code>AbstractRasterStack</code> with a key returns another stack with <code>getindex</code> applied to all the arrays in the stack.</p> <p>source</p> <p># <code>Rasters.Band</code> \u2014 Type.</p> <pre><code>Band &lt;: Dimension\n\nBand(val=:)\n</code></pre> <p>Band <code>Dimension</code> for multi-band rasters.</p> <p>Example:</p> <pre><code>banddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n</code></pre> <p>source</p> <p># <code>Rasters.Mapped</code> \u2014 Type.</p> <pre><code>Mapped &lt;: AbstractProjected\n\nMapped(order, span, sampling, crs, mappedcrs)\nMapped(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs=nothing, mappedcrs)\n</code></pre> <p>An <code>AbstractSampled</code> <code>LookupArray</code>, where the dimension index has been mapped to another projection, usually lat/lon or <code>EPSG(4326)</code>. <code>Mapped</code> matches the dimension format commonly used in netcdf files.</p> <p>Fields and behaviours are identical to <code>Sampled</code> with the addition of <code>crs</code> and <code>mappedcrs</code> fields.</p> <p>The mapped dimension index will be used as for <code>Sampled</code>, but to save in another format the underlying <code>crs</code> may be used to convert it.</p> <p>source</p> <p># <code>Rasters.Projected</code> \u2014 Type.</p> <pre><code>Projected &lt;: AbstractProjected\n\nProjected(order, span, sampling, crs, mappedcrs)\nProjected(; order=AutoOrder(), span=AutoSpan(), sampling=AutoSampling(), crs, mappedcrs=nothing)\n</code></pre> <p>An <code>AbstractSampled</code> <code>LookupArray</code> with projections attached.</p> <p>Fields and behaviours are identical to <code>Sampled</code> with the addition of <code>crs</code> and <code>mappedcrs</code> fields.</p> <p>If both <code>crs</code> and <code>mappedcrs</code> fields contain CRS data (in a <code>GeoFormat</code> wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified <code>mappedcrs</code> projection automatically. A common use case would be to pass <code>mappedcrs=EPSG(4326)</code> to the constructor when loading eg. a GDALarray:</p> <pre><code>GDALarray(filename; mappedcrs=EPSG(4326))\n</code></pre> <p>The underlying <code>crs</code> will be detected by GDAL.</p> <p>If <code>mappedcrs</code> is not supplied (ie. <code>mappedcrs=nothing</code>), the base index will be shown on plots, and selectors will need to use whatever format it is in.</p> <p>source</p> <p># <code>Rasters.Raster</code> \u2014 Type.</p> <pre><code>Raster &lt;: AbsractRaster\n\nRaster(filepath::AbstractString, dims; kw...)\nRaster(A::AbstractArray{T,N}, dims; kw...)\nRaster(A::AbstractRaster; kw...)\n</code></pre> <p>A generic <code>AbstractRaster</code> for spatial/raster array data. It may hold memory-backed arrays or <code>FileArray</code>, that simply holds the <code>String</code> path to an unopened file. This will only be opened lazily when it is indexed with <code>getindex</code> or when <code>read(A)</code> is called. Broadcasting, taking a view, reversing and most other  methods do not load data from disk: they are applied later, lazily.</p> <p>Keywords</p> <ul> <li><code>dims</code>: <code>Tuple</code> of <code>Dimension</code>s for the array.</li> <li><code>lazy</code>: A <code>Bool</code> specifying if to load the stack lazily from disk. <code>false</code> by default.</li> <li><code>name</code>: <code>Symbol</code> name for the array, which will also retreive named layers if <code>Raster</code>   is used on a multi-layered file like a NetCDF.</li> <li><code>missingval</code>: value reprsenting missing data, normally detected form the file. Set manually   when you know the value is not specified or is incorrect. This will not change any   values in the raster, it simply assigns which value is treated as missing. To replace all of   the missing values in the raster, use <code>replace_missing</code>.</li> <li><code>metadata</code>: <code>ArrayMetadata</code> object for the array, or <code>NoMetadata()</code>.</li> <li><code>crs</code>: the coordinate reference system of  the objects <code>XDim</code>/<code>YDim</code> dimensions.    Only set this if you know the detected crs is incrorrect, or it is not present in   the file. The <code>crs</code> is expected to be a GeoFormatTypes.jl <code>CRS</code> or <code>Mixed</code> <code>GeoFormat</code> type.</li> <li><code>mappedcrs</code>: the mapped coordinate reference system of the objects <code>XDim</code>/<code>YDim</code> dimensions.   for <code>Mapped</code> lookups these are the actual values of the index. For <code>Projected</code> lookups   this can be used to index in eg. <code>EPSG(4326)</code> lat/lon values, having it converted automatically.   Only set this if the detected <code>mappedcrs</code> in incorrect, or the file does not have a <code>mappedcrs</code>,   e.g. a tiff. The <code>mappedcrs</code> is expected to be a GeoFormatTypes.jl <code>CRS</code> or <code>Mixed</code> <code>GeoFormat</code> type.</li> <li><code>dropband</code>: drop single band dimensions. <code>true</code> by default.</li> </ul> <p>Internal Keywords</p> <p>In some cases it is possible to set these keywords as well.</p> <ul> <li><code>data</code>: can replace the data in an <code>AbstractRaster</code></li> <li><code>refdims</code>: <code>Tuple of</code> position <code>Dimension</code>s the array was sliced from, defaulting to <code>()</code>.</li> </ul> <p>source</p> <p># <code>Rasters.RasterSeries</code> \u2014 Type.</p> <pre><code>RasterSeries &lt;: AbstractRasterSeries\n\nRasterSeries(rasters::AbstractArray{&lt;:AbstractRaster}, dims; [refdims])\nRasterSeries(stacks::AbstractArray{&lt;:AbstractRasterStack}, dims; [refdims]) \n\nRasterSeries(paths::AbstractArray{&lt;:AbstractString}, dims; child, duplicate_first, kw...)\nRasterSeries(path:::AbstractString, dims; ext, separator, child, duplicate_first, kw...)\n</code></pre> <p>Concrete implementation of <code>AbstractRasterSeries</code>.</p> <p>A <code>RasterSeries</code> is an array of <code>Raster</code>s or <code>RasterStack</code>s, along some dimension(s).</p> <p>Existing <code>Raster</code> <code>RasterStack</code> can be wrapped in a <code>RasterSeries</code>, or new files  can be loaded from an array of <code>String</code> or from a single <code>String</code>.</p> <p>A single <code>String</code> can refer to a whole directory, or the name of a series of files in a directory, sharing a common stem. The differnce between the filenames can be used as the lookup for the series. </p> <p>For example, with some tifs at these paths : </p> <pre><code>\"series_dir/myseries_2001-01-01T00:00:00.tif\"\n\"series_dir/myseries_2002-01-01T00:00:00.tif\"\n</code></pre> <p>We can load a <code>RasterSeries</code> with a <code>DateTime</code> lookup:</p> <pre><code>julia&gt; ser = RasterSeries(\"series_dir/myseries.tif\", Ti(DateTime))\n2-element RasterSeries{Raster,1} with dimensions: \n  Ti Sampled{DateTime} DateTime[DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")] ForwardOrdered Irregular Points\n</code></pre> <p>The <code>DateTime</code> suffix is parsed from the filenames. Using <code>Ti(Int)</code> would try to parse integers intead.</p> <p>Just using the directory will also work, unless there are other files mixed in it:</p> <pre><code>julia&gt; ser = RasterSeries(\"series_dir\", Ti(DateTime))\n2-element RasterSeries{Raster,1} with dimensions: \n  Ti Sampled{DateTime} DateTime[DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")] ForwardOrdered Irregular Points\n</code></pre> <p>Arguments</p> <ul> <li><code>dims</code>: series dimension/s.</li> </ul> <p>Keywords</p> <p>When loading a series from a Vector of <code>String</code> paths or a single <code>String</code> path:</p> <ul> <li><code>child</code>: constructor of child objects for use when filenames are passed in,   can be <code>Raster</code> or <code>RasterStack</code>. Defaults to <code>Raster</code>.</li> <li><code>duplicate_first::Bool</code>: wether to duplicate the dimensions and metadata of the   first file with all other files. This can save load time with a large   series where dimensions are identical. <code>false</code> by default.</li> <li><code>lazy</code>: load files lazily, <code>false</code> by default.</li> <li><code>kw</code>: keywords passed to the child constructor <code>Raster</code> or <code>RasterStack</code>.</li> </ul> <p>When loading a series from a single <code>String</code> path:</p> <ul> <li><code>ext</code>: filename extension such as \".tiff\" or \".nc\".    Use to specify a subset of files if only a directory path is passed in.</li> <li><code>separator</code>: separator used to split lookup elements from the rest of a filename. '_' by default.</li> </ul> <p>Others:</p> <ul> <li><code>refdims</code>: existing reference dimension/s, normally not required.</li> </ul> <p>source</p> <p># <code>Rasters.RasterStack</code> \u2014 Type.</p> <pre><code>RasterStack &lt;: AbstrackRasterStack\n\nRasterStack(data...; name, kw...)\nRasterStack(data::Union{Vector,Tuple}; name, kw...)\nRasterStack(data::NamedTuple; kw...))\nRasterStack(s::AbstractRasterStack; kw...)\nRasterStack(s::AbstractRaster; layersfrom=Band, kw...)\nRasterStack(filename::AbstractString; kw...)\n</code></pre> <p>Load a file path or a <code>NamedTuple</code> of paths as a <code>RasterStack</code>, or convert arguments, a <code>Vector</code> or <code>NamedTuple</code> of <code>Raster</code>s to <code>RasterStack</code>.</p> <p>Arguments</p> <ul> <li><code>data</code>: A <code>NamedTuple</code> of <code>Raster</code>s, or a <code>Vector</code>, <code>Tuple</code> or splatted arguments   of <code>Raster</code>. The latter options must pass a <code>name</code> keyword argument.</li> <li><code>filename</code>: A file (such as netcdf or tif) to be loaded as a stack, or a directory path   containing multiple files.</li> </ul> <p>Keywords</p> <ul> <li><code>name</code>: Used as stack layer names when a <code>Tuple</code>, <code>Vector</code> or splat of <code>Raster</code> is passed in.   Has no effect when <code>NameTuple</code> is used - the <code>NamedTuple</code> keys are the layer names.</li> <li><code>metadata</code>: A <code>Dict</code> or <code>DimensionalData.Metadata</code> object.</li> <li><code>refdims</code>: <code>Tuple</code> of <code>Dimension</code> that the stack was sliced from.</li> <li><code>layersfrom</code>: <code>Dimension</code> to source stack layers from if the file is not already multi-layered.   <code>nothing</code> is default, so that a single <code>RasterStack(raster)</code> is a single layered stack.   <code>RasterStack(raster; layersfrom=Band)</code> will use the bands as layers.</li> <li><code>lazy</code>: A <code>Bool</code> specifying whether to load the stack lazily from disk. <code>false</code> by default.</li> <li><code>dropband</code>: drop single band dimensions when creating stacks from filenames. <code>true</code> by default.</li> </ul> <pre><code>files = (temp=\"temp.tif\", pressure=\"pressure.tif\", relhum=\"relhum.tif\")\nstack = RasterStack(files; mappedcrs=EPSG(4326))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n</code></pre> <p>source</p> <p># <code>DimensionalData.modify</code> \u2014 Method.</p> <pre><code>modify(f, series::AbstractRasterSeries)\n</code></pre> <p>Apply function <code>f</code> to the data of the child object. If the child is an <code>AbstractRasterStack</code> the function will be passed on to its child <code>AbstractRaster</code>s.</p> <p><code>f</code> must return an idenically sized array.</p> <p>This method triggers a complete rebuild of all objects, and disk based objects will be transferred to memory.</p> <p>An example of the usefulnesss of this is for swapping out array backend for an entire series to <code>CuArray</code> from CUDA.jl to copy data to a GPU.</p> <p>source</p> <p># <code>Rasters.aggregate</code> \u2014 Function.</p> <pre><code>aggregate(method, object, scale; filename, progress, skipmissing)\n</code></pre> <p>Aggregate a <code>Raster</code>, or all arrays in a <code>RasterStack</code> or <code>RasterSeries</code>, by <code>scale</code> using <code>method</code>.</p> <p>Arguments</p> <ul> <li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <code>Locus</code> like <code>Start()</code> or <code>Center()</code> that specifies where to sample from in the interval.</li> <li><code>object</code>: Object to aggregate, like <code>AbstractRasterSeries</code>, <code>AbstractStack</code>, <code>AbstractRaster</code> or <code>Dimension</code>.</li> <li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li> </ul> <p>When the aggregation <code>scale</code> of is larger than the array axis, the length of the axis is used.</p> <p>Keywords</p> <ul> <li><code>skipmissingval</code>: if <code>true</code>, any <code>missingval</code> will be skipped during aggregation, so that   only areas of all missing values will be aggregated to <code>missingval</code>. If <code>false</code>, any   aggegrated area containing a <code>missingval</code> will be assigned <code>missingval</code>.</li> <li><code>filename</code>: a filename to write to directly, useful for large files.</li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> <li><code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, Statistics, Plots\nusing Rasters: Center\nst = read(RasterStack(WorldClim{Climate}; month=1))\nag = aggregate(Center(), st, (Y(20), X(20)); skipmissingval=true, progress=false)\nplot(ag)\nsavefig(\"docs/build/aggregate_example.png\"); nothing\n# output\n</code></pre> <p></p> <p>Note: currently it is faster to aggregate over memory-backed arrays. Use <code>read</code> on <code>src</code> before use where required.</p> <p>source</p> <p># <code>Rasters.aggregate!</code> \u2014 Method.</p> <pre><code>aggregate!(method, dst::AbstractRaster, src::AbstractRaster, scale; skipmissingval=false)\n</code></pre> <p>Aggregate array <code>src</code> to array <code>dst</code> by <code>scale</code>, using <code>method</code>.</p> <p>Arguments</p> <ul> <li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <code>Locus</code> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li> <li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index in the <code>src</code> array.</li> </ul> <p>When the aggregation <code>scale</code> of is larger than the array axis, the length of the axis is used.</p> <p>Keywords</p> <ul> <li><code>progress</code>: show a progress bar.</li> <li><code>skipmissingval</code>: if <code>true</code>, any <code>missingval</code> will be skipped during aggregation, so that   only areas of all missing values will be aggregated to <code>missingval</code>. If <code>false</code>, any   aggegrated area containing a <code>missingval</code> will be assigned <code>missingval</code>.</li> </ul> <p>Note: currently it is much faster to aggregate over memory-backed arrays. Use <code>read</code> on <code>src</code> before use where required.</p> <p>source</p> <p># <code>Rasters.boolmask</code> \u2014 Function.</p> <pre><code>boolmask(obj::Raster; [missingval])\nboolmask(obj; [to, res, size])\n</code></pre> <p>Create a mask array of <code>Bool</code> values, from another <code>Raster</code>. An <code>AbstractRasterStack</code> or <code>AbstractRasterSeries</code> are also accepted, but a mask is taken of the first layer or object not all of them.</p> <p>The array returned from calling <code>boolmask</code> on a <code>AbstractRaster</code> is a <code>Raster</code> with the same dimensions as the original array and a <code>missingval</code> of <code>false</code>.</p> <p>Arguments</p> <ul> <li><code>obj</code>: a <code>Raster</code>, a GeoInterface.jl geometry, or a vector or table of geometries.</li> </ul> <p><code>Raster</code> / <code>RasterStack</code> Keywords</p> <ul> <li><code>missingval</code>: The missing value of the source array, with default <code>missingval(raster)</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>to</code>: a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code> or <code>Extents.Extent</code>.   If no <code>to</code> object is provided the extent will be calculated from the geometries,   Additionally, when no <code>to</code> object or an <code>Extent</code> is passed for <code>to</code>, the <code>size</code>   or <code>res</code> keyword must also be used.</li> <li><code>res</code>: the resolution of the dimensions, a <code>Real</code> or <code>Tuple{&lt;:Real,&lt;:Real}</code>.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>size</code> is not used.</li> <li><code>size</code>: the size of the output array, as a <code>Tuple{Int,Int}</code> or single <code>Int</code> for a square.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>res</code> is not used.</li> <li><code>crs</code>: a <code>crs</code> which will be attached to the resulting raster when <code>to</code> not passed  or is an <code>Extent</code>. Otherwise the crs from <code>to</code> is used.</li> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code> geometries.   using points or lines as polygons may have unexpected results.</li> <li> <p><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the polygon <code>:touches</code> the pixel, or that are completely <code>:inside</code> the polygon.   The default is <code>:center</code>.</p> </li> <li> <p><code>threaded</code>: run operations in parallel, <code>false</code> by default. In some circumstances <code>threaded</code>    can give large speedups over single-threaded operation. This can be true for complicated    geometries written into low-resolution rasters, but may not be for simple geometries with    high-resolution rasters. With very large rasters threading may be counter productive due    to excessing memory use. Caution should also be used: <code>threaded</code> should not be used in in-place    functions wrinting to <code>BitArray</code> or other arrays where race conditions can occur.</p> </li> <li><code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide.</li> </ul> <p>And specifically for <code>shape=:polygon</code>:</p> <ul> <li><code>boundary</code>: include pixels where the <code>:center</code> is inside the polygon, where   the line <code>:touches</code> the pixel, or that are completely <code>:inside</code> inside the polygon.   The default is <code>:center</code>.</li> </ul> <p>For tabular data, feature collections and other iterables</p> <ul> <li><code>collapse</code>: if <code>true</code>, collapse all geometry masks into a single mask. Otherwise   return a Raster with an additional <code>geometry</code> dimension, so that each slice   along this axis is the mask of the <code>geometry</code> opbject of each row of the   table, feature in the feature collection, or just each geometry in the iterable.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nboolmask(wc) |&gt; plot\n\nsavefig(\"docs/build/boolmask_example.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.classify</code> \u2014 Function.</p> <pre><code>classify(x, pairs; lower=(&gt;=), upper=(&lt;), others=nothing)\nclassify(x, pairs...; lower, upper, others)\n</code></pre> <p>Create a new array with values in <code>x</code> classified by the values in <code>pairs</code>.</p> <p><code>pairs</code> can hold tuples fo values <code>(2, 3)</code>, a <code>Fix2</code> function e.g. <code>&lt;=(1)</code>, a <code>Tuple</code> of <code>Fix2</code> e.g. <code>(&gt;=(4), &lt;(7))</code>, or an IntervalSets.jl interval, e.g. <code>3..9</code> or <code>OpenInterval(10, 12)</code>. <code>pairs</code> can also be a <code>n * 3</code> matrix where each row is lower bounds, upper bounds, replacement.</p> <p>If tuples or a <code>Matrix</code> are used, the <code>lower</code> and <code>upper</code> keywords define how the lower and upper boundaries are chosen.</p> <p>If <code>others</code> is set other values not covered in <code>pairs</code> will be set to that values.</p> <p>Arguments</p> <ul> <li><code>x</code>: a <code>Raster</code> or <code>RasterStack</code></li> <li><code>pairs</code>: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of <code>Fix2</code> like <code>(&gt;(x), &lt;(y)</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>lower</code>: Which comparison (<code>&lt;</code> or <code>&lt;=</code>) to use for lower values, if <code>Fix2</code> are not used.</li> <li><code>upper</code>: Which comparison (<code>&gt;</code> or <code>&gt;=</code>) to use for upper values, if <code>Fix2</code> are not used.</li> <li><code>others</code>: A value to assign to all values not included in <code>pairs</code>.   Passing <code>nothing</code> (the default) will leave them unchanged.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{Climate}, :tavg; month=1)\nclasses = &lt;=(15) =&gt; 10,\n          15..25 =&gt; 20,\n          25..35 =&gt; 30,\n          &gt;(35) =&gt; 40\nclassified = classify(A, classes; others=0, missingval=0)\nplot(classified; c=:magma)\n\nsavefig(\"docs/build/classify_example.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.classify!</code> \u2014 Method.</p> <pre><code>classify!(x, pairs...; lower, upper, others)\nclassify!(x, pairs; lower, upper, others)\n</code></pre> <p>Classify the values of <code>x</code> in-place, by the values in <code>pairs</code>.</p> <p>If <code>Fix2</code> is not used, the <code>lower</code> and <code>upper</code> keywords</p> <p>If <code>others</code> is set other values not covered in <code>pairs</code> will be set to that values.</p> <p>Arguments</p> <ul> <li><code>x</code>: a <code>Raster</code> or <code>RasterStack</code></li> <li><code>pairs</code>: each pair contains a value and a replacement, a tuple of lower and upper   range and a replacement, or a Tuple of <code>Fix2</code> like <code>(&gt;(x), &lt;(y)</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>lower</code>: Which comparison (<code>&lt;</code> or <code>&lt;=</code>) to use for lower values, if <code>Fix2</code> are not used.</li> <li><code>upper</code>: Which comparison (<code>&gt;</code> or <code>&gt;=</code>) to use for upper values, if <code>Fix2</code> are not used.</li> <li><code>others</code>: A value to assign to all values not included in <code>pairs</code>.   Passing <code>nothing</code> (the default) will leave them unchanged.</li> </ul> <p>Example</p> <p><code>classify!</code> to disk, with key steps:</p> <ul> <li>copying a tempory file so we don't write over the RasterDataSources.jl version.</li> <li>use <code>open</code> with <code>write=true</code> to open the file with disk-write permissions.</li> <li>use <code>Float32</code> like <code>10.0f0</code> for all our replacement values and <code>other</code>, because   the file is stored as <code>Float32</code>. Attempting to write some other type will fail.</li> </ul> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots\n# Download and copy the file\nfilename = getraster(WorldClim{Climate}, :tavg; month=6)\ntempfile = tempname() * \".tif\"\ncp(filename, tempfile)\n# Define classes\nclasses = (5, 15) =&gt; 10,\n          (15, 25) =&gt; 20,\n          (25, 35) =&gt; 30,\n          &gt;=(35) =&gt; 40\n# Open the file with write permission\nopen(Raster(tempfile); write=true) do A\n    classify!(A, classes; others=0)\nend\n# Open it again to plot the changes\nplot(Raster(tempfile); c=:magma)\n\nsavefig(\"docs/build/classify_bang_example.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.combine</code> \u2014 Method.</p> <pre><code>combine(A::Union{AbstractRaster,AbstractRasterStack,AbstracRasterSeries}, [dims]) =&gt; Raster\n</code></pre> <p>Combine a <code>RasterSeries</code> along some dimension/s, creating a new <code>Raster</code> or <code>RasterStack</code>, depending on the contents of the series.</p> <p>If <code>dims</code> are passed, only the specified dimensions will be combined with a <code>RasterSeries</code> returned, unless <code>dims</code> is all the dims in the series.</p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p>&lt;a id='Rasters.convertlookup-Tuple{Type{&lt;:LookupArray}, AbstractDimArray}' href='#Rasters.convertlookup-Tuple{Type{&lt;:LookupArray}, AbstractDimArray}'&gt;# <code>Rasters.convertlookup</code> \u2014 Method.</p> <pre><code>convertlookup(dstlookup::Type{&lt;:LookupArray}, x)\n</code></pre> <p>Convert the dimension lookup between <code>Projected</code> and <code>Mapped</code>. Other dimension lookups pass through unchanged.</p> <p>This is used to e.g. save a netcdf file to GeoTiff.</p> <p>source</p> <p># <code>Rasters.coverage!</code> \u2014 Method.</p> <pre><code>coverage!(A, geom; [mode, scale])\n</code></pre> <p>Calculate the area of a raster covered by GeoInterface.jl compatible geomtry <code>geom</code>, as a fraction.</p> <p>Each pixel is assigned a grid of points (by default 10 x 10) that are each checked to be inside the geometry. The sum divided by the number of points to give coverage.</p> <p>In pracice, most pixel coverage is not calculated this way - shortcuts that  produce the same result are taken wherever possible.</p> <p>If <code>geom</code> is an <code>AbstractVector</code> or table, the <code>mode</code> keyword will determine how coverage is combined.</p> <p>Keywords</p> <ul> <li> <p><code>mode</code>: method for combining multiple geometries - <code>union</code> or <code>sum</code>. </p> <ul> <li><code>union</code> (the default) gives the areas covered by all geometries. Usefull in spatial coverage where overlapping regions should not be counted twice. The returned raster will contain <code>Float64</code> values between <code>0.0</code> and <code>1.0</code>.</li> <li><code>sum</code> gives the summed total of the areas covered by all geometries, as in taking the sum of running <code>coverage</code> separately on all geometries. The returned values are positive <code>Float64</code>.</li> </ul> <p>For a single geometry, the <code>mode</code> keyword has no effect - the result is the same.   * <code>scale</code>: <code>Integer</code> scale of pixel subdivision. The default of <code>10</code> means each pixel has    10 x 10 or 100 points that contribute to coverage. Using <code>100</code> means 10,000 points   contribute. Performance will decline as <code>scale</code> increases. Memory use will grow    by <code>scale^2</code> when <code>mode=:union</code>.   * <code>threaded</code>: run operations in parallel, <code>false</code> by default. In some circumstances <code>threaded</code>    can give large speedups over single-threaded operation. This can be true for complicated    geometries written into low-resolution rasters, but may not be for simple geometries with    high-resolution rasters. With very large rasters threading may be counter productive due    to excessing memory use. Caution should also be used: <code>threaded</code> should not be used in in-place    functions wrinting to <code>BitArray</code> or other arrays where race conditions can occur.   * <code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide.   * <code>vebose</code>: whether to print messages about potential problems. <code>true</code> by default.</p> </li> </ul> <p>source</p> <p># <code>Rasters.coverage</code> \u2014 Method.</p> <pre><code>coverage(mode, geom; [to, res, size, scale, verbose, progress])\ncoverage(geom; [to, mode, res, size, scale, verbose, progress])\n</code></pre> <p>Calculate the area of a raster covered by GeoInterface.jl compatible geomtry <code>geom</code>, as a fraction.</p> <p>Each pixel is assigned a grid of points (by default 10 x 10) that are each checked to be inside the geometry. The sum divided by the number of points to give coverage.</p> <p>In pracice, most pixel coverage is not calculated this way - shortcuts that  produce the same result are taken wherever possible.</p> <p>If <code>geom</code> is an <code>AbstractVector</code> or table, the <code>mode</code> keyword will determine how coverage is combined.</p> <p>Keywords</p> <ul> <li> <p><code>mode</code>: method for combining multiple geometries - <code>union</code> or <code>sum</code>. </p> <ul> <li><code>union</code> (the default) gives the areas covered by all geometries. Usefull in spatial coverage where overlapping regions should not be counted twice. The returned raster will contain <code>Float64</code> values between <code>0.0</code> and <code>1.0</code>.</li> <li><code>sum</code> gives the summed total of the areas covered by all geometries, as in taking the sum of running <code>coverage</code> separately on all geometries. The returned values are positive <code>Float64</code>.</li> </ul> <p>For a single geometry, the <code>mode</code> keyword has no effect - the result is the same.   * <code>scale</code>: <code>Integer</code> scale of pixel subdivision. The default of <code>10</code> means each pixel has    10 x 10 or 100 points that contribute to coverage. Using <code>100</code> means 10,000 points   contribute. Performance will decline as <code>scale</code> increases. Memory use will grow    by <code>scale^2</code> when <code>mode=:union</code>.   * <code>threaded</code>: run operations in parallel, <code>false</code> by default. In some circumstances <code>threaded</code>    can give large speedups over single-threaded operation. This can be true for complicated    geometries written into low-resolution rasters, but may not be for simple geometries with    high-resolution rasters. With very large rasters threading may be counter productive due    to excessing memory use. Caution should also be used: <code>threaded</code> should not be used in in-place    functions wrinting to <code>BitArray</code> or other arrays where race conditions can occur.   * <code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide.   * <code>vebose</code>: whether to print messages about potential problems. <code>true</code> by default.</p> </li> <li> <p><code>to</code>: a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code> or <code>Extents.Extent</code>.   If no <code>to</code> object is provided the extent will be calculated from the geometries,   Additionally, when no <code>to</code> object or an <code>Extent</code> is passed for <code>to</code>, the <code>size</code>   or <code>res</code> keyword must also be used.</p> </li> <li><code>size</code>: the size of the output array, as a <code>Tuple{Int,Int}</code> or single <code>Int</code> for a square.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>res</code> is not used.</li> <li><code>res</code>: the resolution of the dimensions, a <code>Real</code> or <code>Tuple{&lt;:Real,&lt;:Real}</code>.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>size</code> is not used.</li> </ul> <p>source</p> <p># <code>Rasters.crop</code> \u2014 Function.</p> <pre><code>crop(x; to)\ncrop(xs...; to)\n</code></pre> <p>Crop one or multiple <code>AbstractRaster</code> or <code>AbstractRasterStack</code> <code>x</code> to match the size of the object <code>to</code>, or smallest of any dimensions that are shared.</p> <p><code>crop</code> is lazy, using a <code>view</code> into the object rather than alocating new memory.</p> <p>Keywords</p> <ul> <li><code>to</code>: the object to crop to. If no <code>to</code> keyword is passed, the smallest shared   area of all <code>xs</code> is used.</li> <li><code>touches</code>: <code>true</code> or <code>false</code>. Whether to use <code>Touches</code> wraper on the object extent.  When lines need to be included in e.g. zonal statistics, <code>true</code> should be used.</li> </ul> <p>As <code>crop</code> is lazy, <code>filename</code> and <code>suffix</code> keywords are not used.</p> <p>Example</p> <p>Crop to another raster:</p> <pre><code>using Rasters, RasterDataSources, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out New Zealand from the evenness raster\nnz_bounds = X(165 .. 180), Y(-50 .. -32)\nnz_evenness = evenness[nz_bounds...]\n\n# Crop range to match evenness\nnz_range = crop(rnge; to=nz_evenness)\nplot(nz_range)\n\nsavefig(\"docs/build/nz_crop_example.png\")\nnothing\n\n# output\n</code></pre> <p></p> <p>Crop to a polygon:</p> <pre><code>using Rasters, RasterDataSources, Plots, Dates, Shapefile, Downloads\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\nshp = Shapefile.Handle(shapefile_name).shapes[6]\n\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nargentina_evenness = crop(evenness; to=shp)\nplot(argentina_evenness)\n\nsavefig(\"docs/build/argentina_crop_example.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.crs</code> \u2014 Function.</p> <pre><code>crs(x)\n</code></pre> <p>Get the projected coordinate reference system of a <code>Y</code> or <code>X</code> <code>Dimension</code>, or of the <code>Y</code>/<code>X</code> dims of an <code>AbstractRaster</code>.</p> <p>For <code>Mapped</code> lookup this may be <code>nothing</code> as there may be no projected coordinate reference system at all. See <code>setcrs</code> to set it manually.</p> <p>source</p> <p># <code>Rasters.disaggregate</code> \u2014 Function.</p> <pre><code>disaggregate(method, object, scale; filename, progress, keys)\n</code></pre> <p>Disaggregate array, or all arrays in a stack or series, by some scale.</p> <p>Arguments</p> <ul> <li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <code>Locus</code> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li> <li><code>object</code>: Object to aggregate, like <code>AbstractRasterSeries</code>, <code>AbstractStack</code>, <code>AbstractRaster</code> or a <code>Dimension</code>.</li> <li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index.</li> </ul> <p>Keywords</p> <ul> <li><code>progress</code>: show a progress bar.</li> </ul> <p>Note: currently it is faster to aggregate over memory-backed arrays. Use <code>read</code> on <code>src</code> before use where required.</p> <p>source</p> <p># <code>Rasters.disaggregate!</code> \u2014 Method.</p> <pre><code>disaggregate!(method, dst::AbstractRaster, src::AbstractRaster, filename, scale)\n</code></pre> <p>Disaggregate array <code>src</code> to array <code>dst</code> by some scale, using <code>method</code>.</p> <ul> <li><code>method</code>: a function such as <code>mean</code> or <code>sum</code> that can combine the value of multiple cells to generate the aggregated cell, or a <code>Locus</code> like <code>Start()</code> or <code>Center()</code> that species where to sample from in the interval.</li> <li><code>scale</code>: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any <code>Dimension</code>, <code>Selector</code> or <code>Int</code> combination you can usually use in <code>getindex</code>. Using a <code>Selector</code> will determine the scale by the distance from the start of the index in the <code>src</code> array.</li> </ul> <p>Note: currently it is faster to aggregate over memory-backed arrays. Use <code>read</code> on <code>src</code> before use where required.</p> <p>source</p> <p># <code>Rasters.extend</code> \u2014 Function.</p> <pre><code>extend(xs...; [to])\nextend(xs; [to])\nextend(x::Union{AbstractRaster,AbstractRasterStack}; to, kw...)\n</code></pre> <p>Extend one or multiple <code>AbstractRaster</code> to match the area covered by all <code>xs</code>, or by the keyword argument <code>to</code>.</p> <p>Keywords</p> <ul> <li><code>to</code>: the Raster or dims to extend to. If no <code>to</code> keyword is passed, the largest   shared area of all <code>xs</code> is used.</li> <li><code>touches</code>: <code>true</code> or <code>false</code>. Whether to use <code>Touches</code> wraper on the object extent.  When lines need to be included in e.g. zonal statistics, <code>true</code> shoudle be used.</li> <li><code>filename</code>: a filename to write to directly, useful for large files.</li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> </ul> <pre><code>using Rasters, RasterDataSources, Plots\nevenness = Raster(EarthEnv{HabitatHeterogeneity}, :evenness)\nrnge = Raster(EarthEnv{HabitatHeterogeneity}, :range)\n\n# Roughly cut out South America\nsa_bounds = X(-88 .. -32), Y(-57 .. 13)\nsa_evenness = evenness[sa_bounds...]\n\n# Extend range to match the whole-world raster\nsa_range = extend(sa_evenness; to=rnge)\nplot(sa_range)\n\nsavefig(\"docs/build/extend_example.png\")\nnothing\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.extract</code> \u2014 Function.</p> <pre><code>extract(x, geoms; atol)\n</code></pre> <p>Extracts the value of <code>Raster</code> or <code>RasterStack</code> at given points, returning an iterable of <code>NamedTuple</code> with properties for <code>:geometry</code> and raster or stack layer values.</p> <p>Note that if objects have more dimensions than the length of the point tuples, sliced arrays or stacks will be returned instead of single values.</p> <p>Arguments</p> <ul> <li><code>x</code>: a <code>Raster</code> or <code>RasterStack</code> to extract values from.</li> <li><code>geoms</code>: GeoInterface.jl compatible geometries, or tables or iterables of geometries.</li> </ul> <p>Keywords</p> <ul> <li><code>atol</code>: a tolorerance for floating point lookup values for when the <code>LookupArray</code>   contains <code>Points</code>. <code>atol</code> is ignored for <code>Intervals</code>.</li> </ul> <p>Example</p> <p>Here we extact points matching the occurrence of the Mountain Pygmy Possum, Burramis parvus. This could be used to fit a species distribution model.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, GBIF2, CSV\n\n# Get a stack of BioClim layers, and replace missing values with `missing`\nst = RasterStack(WorldClim{BioClim}, (1, 3, 5, 7, 12)) |&gt; replace_missing\n\n# Download some occurrence data\nobs = GBIF2.occurrence_search(\"Burramys parvus\"; limit=5, year=\"2009\")\n\n# Convert observations to points\npnts = collect((o.decimalLongitude, o.decimalLatitude) for o in obs if !ismissing(o.decimalLongitude))\n\n# use `extract` to get values for all layers at each observation point.\n# We `collect` to get a `Vector` from the lazy iterator.\ncollect(extract(st, pnts))\n\n# output\n5-element Vector{NamedTuple{(:geometry, :bio1, :bio3, :bio5, :bio7, :bio12)}}:\n (geometry = (0.21, 40.07), bio1 = 17.077084f0, bio3 = 41.20417f0, bio5 = 30.1f0, bio7 = 24.775f0, bio12 = 446.0f0)\n (geometry = (0.03, 39.97), bio1 = 17.076923f0, bio3 = 39.7983f0, bio5 = 29.638462f0, bio7 = 24.153847f0, bio12 = 441.0f0)\n (geometry = (0.03, 39.97), bio1 = 17.076923f0, bio3 = 39.7983f0, bio5 = 29.638462f0, bio7 = 24.153847f0, bio12 = 441.0f0)\n (geometry = (0.52, 40.37), bio1 = missing, bio3 = missing, bio5 = missing, bio7 = missing, bio12 = missing)\n (geometry = (0.32, 40.24), bio1 = 16.321388f0, bio3 = 41.659454f0, bio5 = 30.029825f0, bio7 = 25.544561f0, bio12 = 480.0f0)\n</code></pre> <p>source</p> <p># <code>Rasters.mappedbounds</code> \u2014 Function.</p> <pre><code>mappedbounds(x)\n</code></pre> <p>Get the bounds converted to the <code>mappedcrs</code> value.</p> <p>Whithout ArchGDAL loaded, this is just the regular bounds.</p> <p>source</p> <p># <code>Rasters.mappedcrs</code> \u2014 Function.</p> <pre><code>mappedcrs(x)\n</code></pre> <p>Get the mapped coordinate reference system for the <code>Y</code>/<code>X</code> dims of an array.</p> <p>In <code>Projected</code> lookup this is used to convert <code>Selector</code> values form the mappedcrs defined projection to the underlying projection, and to show plot axes in the mapped projection.</p> <p>In <code>Mapped</code> lookup this is the coordinate reference system of the index values. See <code>setmappedcrs</code> to set it manually.</p> <p>source</p> <p># <code>Rasters.mappedindex</code> \u2014 Function.</p> <pre><code>mappedindex(x)\n</code></pre> <p>Get the index value of a dimension converted to the <code>mappedcrs</code> value.</p> <p>Whithout ArchGDAL loaded, this is just the regular dim value.</p> <p>source</p> <p># <code>Rasters.mask!</code> \u2014 Function.</p> <pre><code>mask!(x; with, missingval=missingval(A))\n</code></pre> <p>Mask <code>A</code> by the missing values of <code>with</code>, or by all values outside <code>with</code> if it is a polygon.</p> <p>If <code>with</code> is a polygon, creates a new array where points falling outside the polygon have been replaced by <code>missingval(A)</code>.</p> <p>Return a new array with values of <code>A</code> masked by the missing values of <code>with</code>, or by a polygon.</p> <p>Arguments</p> <ul> <li><code>x</code>: a <code>Raster</code> or <code>RasterStack</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>with</code>: another <code>AbstractRaster</code>, a <code>AbstractVector</code> of <code>Tuple</code> points,   or any GeoInterface.jl <code>AbstractGeometry</code>. The coordinate reference system   of the point must match <code>crs(A)</code>.</li> <li><code>missingval</code>: the missing value to write to A in masked areas,   by default <code>missingval(A)</code>.</li> </ul> <p>Example</p> <p>Mask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask to match the size and projection.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates\n\n# Load and plot the file\nawap = read(RasterStack(AWAP, (:tmin, :tmax); date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45), c=:imola)\n\n# Create a mask my resampling a worldclim file\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask\nmask!(awap; with=wc_mask)\nb = plot(awap; clims=(10, 45))\n\nsavefig(a, \"docs/build/mask_bang_example_before.png\");\nsavefig(b, \"docs/build/mask_bang_example_after.png\"); nothing\n\n# output\n</code></pre> <p>Before <code>mask!</code>:</p> <p></p> <p>After <code>mask!</code>:</p> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.mask</code> \u2014 Method.</p> <pre><code>mask(A:AbstractRaster; with, missingval=missingval(A))\nmask(x; with)\n</code></pre> <p>Return a new array with values of <code>A</code> masked by the missing values of <code>with</code>, or by the shape of <code>with</code>, if <code>with</code> is a geometric object.</p> <p>Arguments</p> <ul> <li><code>x</code>: a <code>Raster</code> or <code>RasterStack</code></li> </ul> <p>Keywords</p> <ul> <li><code>with</code>: an <code>AbstractRaster</code>, or any GeoInterface.jl compatible objects   or table. The coordinate reference system of the point must match <code>crs(A)</code>.</li> <li><code>missingval</code>: the missing value to use in the returned file.</li> <li><code>filename</code>: a filename to write to directly, useful for large files.</li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> </ul> <p>Geometry keywords</p> <p>These can be used when <code>with</code> is a GeoInterface.jl compatible object:</p> <ul> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code> geometries.   using points or lines as polygons may have unexpected results.</li> <li><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the polygon <code>:touches</code> the pixel, or that are completely <code>:inside</code> the polygon.   The default is <code>:center</code>.</li> </ul> <p>Example</p> <p>Mask an unmasked AWAP layer with a masked WorldClim layer, by first resampling the mask.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates\n\n# Load and plot the file\nawap = read(Raster(AWAP, :tmax; date=DateTime(2001, 1, 1)))\na = plot(awap; clims=(10, 45))\n\n# Create a mask my resampling a worldclim file\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nwc_mask = resample(wc; to=awap)\n\n# Mask\nawap_masked = mask(awap; with=wc_mask)\nb = plot(awap_masked; clims=(10, 45))\n\nsavefig(a, \"docs/build/mask_example_before.png\");\nsavefig(b, \"docs/build/mask_example_after.png\"); nothing\n# output\n</code></pre> <p>Before <code>mask</code>:</p> <p></p> <p>After <code>mask</code>:</p> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.missingmask</code> \u2014 Method.</p> <pre><code>missingmask(obj::Raster; kw...)\nmissingmask(obj; [to, res, size, collapse])\n</code></pre> <p>Create a mask array of <code>missing</code> and <code>true</code> values, from another <code>Raster</code>. <code>AbstractRasterStack</code> or <code>AbstractRasterSeries</code> are also accepted, but a mask is taken of the first layer or object not all of them.</p> <p>For <code>AbstractRaster</code> the default <code>missingval</code> is <code>missingval(A)</code>, but others can be chosen manually.</p> <p>The array returned from calling <code>missingmask</code> on a <code>AbstractRaster</code> is a <code>Raster</code> with the same size and fields as the original array.</p> <p>Keywords</p> <ul> <li><code>to</code>: a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code> or <code>Extents.Extent</code>.   If no <code>to</code> object is provided the extent will be calculated from the geometries,   Additionally, when no <code>to</code> object or an <code>Extent</code> is passed for <code>to</code>, the <code>size</code>   or <code>res</code> keyword must also be used.</li> <li><code>res</code>: the resolution of the dimensions, a <code>Real</code> or <code>Tuple{&lt;:Real,&lt;:Real}</code>.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>size</code> is not used.</li> <li><code>size</code>: the size of the output array, as a <code>Tuple{Int,Int}</code> or single <code>Int</code> for a square.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>res</code> is not used.</li> <li><code>crs</code>: a <code>crs</code> which will be attached to the resulting raster when <code>to</code> not passed  or is an <code>Extent</code>. Otherwise the crs from <code>to</code> is used.</li> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code> geometries.   using points or lines as polygons may have unexpected results.</li> <li><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the polygon <code>:touches</code> the pixel, or that are completely <code>:inside</code> the polygon.   The default is <code>:center</code>.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates\nwc = Raster(WorldClim{Climate}, :prec; month=1)\nmissingmask(wc) |&gt; plot\n\nsavefig(\"docs/build/missingmask_example.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.missingval</code> \u2014 Function.</p> <pre><code>missingval(x)\n</code></pre> <p>Returns the value representing missing data in the dataset</p> <p>source</p> <p># <code>Rasters.mosaic!</code> \u2014 Method.</p> <pre><code>mosaic!(f, x, regions...; missingval, atol)\nmosaic!(f, x, regions::Tuple; missingval, atol)\n</code></pre> <p>Combine <code>regions</code> in <code>x</code> using the function <code>f</code>.</p> <p>Arguments</p> <ul> <li><code>f</code> a function (e.g. <code>mean</code>, <code>sum</code>, <code>first</code> or <code>last</code>) that is applied to   values where <code>regions</code> overlap.</li> <li><code>x</code>: A <code>Raster</code> or <code>RasterStack</code>. May be a an opened disk-based <code>Raster</code>,   the result will be written to disk.   With the current algorithm, the read speed is slow.</li> <li><code>regions</code>: source objects to be joined. These should be memory-backed   (use <code>read</code> first), or may experience poor performance. If all objects have   the same extent, <code>mosaic</code> is simply a merge.</li> </ul> <p>Keywords</p> <ul> <li><code>missingval</code>: Fills empty areas, and defualts to the `missingval/   of the first layer.</li> <li><code>atol</code>: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.</li> </ul> <p>Example</p> <p>Cut out Australia and Africa stacks, then combined them into a single stack.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Statistics, Plots\nst = read(RasterStack(WorldClim{Climate}; month=1))\naus = st[X=100.0 .. 160.0, Y=-50.0 .. -10.0]\nafrica = st[X=-20.0 .. 60.0, Y=-40.0 .. 35.0]\nmosaic!(first, st, aus, africa)\nplot(st)\nsavefig(\"docs/build/mosaic_bang_example.png\")\nnothing\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.mosaic</code> \u2014 Method.</p> <pre><code>mosaic(f, regions...; missingval, atol)\nmosaic(f, regions; missingval, atol)\n</code></pre> <p>Combine <code>regions</code> into a single raster.</p> <p>Arguments</p> <ul> <li><code>f</code>: A reducing function (<code>mean</code>, <code>sum</code>, <code>first</code>, <code>last</code> etc.)   for values where <code>regions</code> overlap.</li> <li><code>regions</code>: Iterable or splatted <code>Raster</code> or <code>RasterStack</code>.</li> </ul> <p>Keywords</p> <ul> <li><code>missingval</code>: Fills empty areas, and defualts to the   <code>missingval</code> of the first region.</li> <li><code>atol</code>: Absolute tolerance for comparison between index values.   This is often required due to minor differences in range values   due to floating point error. It is not applied to non-float dimensions.   A tuple of tolerances may be passed, matching the dimension order.</li> <li><code>filename</code>: a filename to write to directly, useful for large files.</li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> </ul> <p>If your mosaic has has apparent line errors, increase the <code>atol</code> value.</p> <p>Example</p> <p>Here we cut out Australia and Africa from a stack, and join them with <code>mosaic</code>.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots\nst = RasterStack(WorldClim{Climate}; month=1);\n\nafrica = st[X(-20.0 .. 60.0), Y(-40.0 .. 35.0)]\na = plot(africa)\n\naus = st[X(100.0 .. 160.0), Y(-50.0 .. -10.0)]\nb = plot(aus)\n\n# Combine with mosaic\nmos = mosaic(first, aus, africa)\nc = plot(mos)\n\nsavefig(a, \"docs/build/mosaic_example_africa.png\")\nsavefig(b, \"docs/build/mosaic_example_aus.png\")\nsavefig(c, \"docs/build/mosaic_example_combined.png\")\nnothing\n# output\n</code></pre> <p>Individual continents</p> <p></p> <p></p> <p>Mosaic of continents</p> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.points</code> \u2014 Method.</p> <pre><code>points(A::AbstractRaster; dims=(YDim, XDim), ignore_missing) =&gt; Array{Tuple}\n</code></pre> <p>Returns a generator of the points in <code>A</code> for dimensions in <code>dims</code>, where points are a tuple of the values in each specified dimension index.</p> <p>Keywords</p> <ul> <li><code>dims</code> the dimensions to return points from. The first slice of other   layers will be used.</li> <li><code>ignore_missing</code>: wether to ignore missing values in the array when considering   points. If <code>true</code>, all points in the dimensions will be returned, if <code>false</code>   only the points that are not <code>=== missingval(A)</code> will be returned.</li> </ul> <p>The order of <code>dims</code> determines the order of the points.</p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.rasterize</code> \u2014 Function.</p> <pre><code>rasterize([reducer], data; kw...)\n</code></pre> <p>Rasterize a GeoInterface.jl compatable geometry or feature, or a Tables.jl table with a <code>:geometry</code> column of GeoInterface.jl objects, or <code>X</code>, <code>Y</code> points columns.</p> <p>Arguments</p> <ul> <li><code>reducer</code>: a reducing function to reduce the fill value for all geometries that   cover or touch a pixel down to a single value. The default is <code>last</code>.   Any  that takes an iterable and returns a single value will work, including   custom functions. However, there are optimisations for built-in methods   including <code>sum</code>, <code>first</code>, <code>last</code>, <code>minimum</code>, <code>maximum</code>, <code>extrema</code> and <code>Statistics.mean</code>.   These may be an order of magnitude or more faster than   <code>count</code> is a special-cased as it does not need a fill value.</li> <li><code>data</code>: a GeoInterface.jl <code>AbstractGeometry</code>, or a nested <code>Vector</code> of <code>AbstractGeometry</code>,   or a Tables.jl compatible object containing a <code>:geometry</code> column or points and values columns.</li> </ul> <p>Keywords</p> <p>These are detected automatically from <code>data</code> where possible.</p> <ul> <li><code>to</code>: a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code> or <code>Extents.Extent</code>.   If no <code>to</code> object is provided the extent will be calculated from the geometries,   Additionally, when no <code>to</code> object or an <code>Extent</code> is passed for <code>to</code>, the <code>size</code>   or <code>res</code> keyword must also be used.</li> <li><code>res</code>: the resolution of the dimensions, a <code>Real</code> or <code>Tuple{&lt;:Real,&lt;:Real}</code>.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>size</code> is not used.</li> <li><code>size</code>: the size of the output array, as a <code>Tuple{Int,Int}</code> or single <code>Int</code> for a square.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>res</code> is not used.</li> <li><code>crs</code>: a <code>crs</code> which will be attached to the resulting raster when <code>to</code> not passed  or is an <code>Extent</code>. Otherwise the crs from <code>to</code> is used.</li> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code> geometries.   using points or lines as polygons may have unexpected results.</li> <li> <p><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the polygon <code>:touches</code> the pixel, or that are completely <code>:inside</code> the polygon.   The default is <code>:center</code>.</p> </li> <li> <p><code>fill</code>: the value or values to fill a polygon with. A <code>Symbol</code> or tuple of <code>Symbol</code> will   be used to retrieve properties from features or column values from table rows. An array   or other iterable will be used for each geometry, in order. <code>fill</code> can also be a function of    the current value, e.g. <code>x -&gt; x + 1</code>.</p> </li> <li><code>op</code>: A reducing function that accepts two values and returns one, like <code>min</code> to <code>minimum</code>.   For common methods this will be assigned for you, or is not required. But you can use it   instead of a <code>reducer</code> as it will usually be faster.</li> <li><code>shape</code>: force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code>, where possible   Points can't be treated as lines or polygons, and lines may not work as polygons, but   an attempt will be made.</li> <li><code>geometrycolumn</code>: <code>Symbol</code> to manually select the column the geometries are in   when <code>data</code> is a Tables.jl compatible table, or a tuple of <code>Symbol</code> for columns of   point coordinates.</li> <li><code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide..</li> <li><code>verbose</code>: print information and warnings whne there are problems with the rasterisation.   <code>true</code> by default.</li> <li> <p><code>threaded</code>: run operations in parallel, <code>false</code> by default. In some circumstances <code>threaded</code>    can give large speedups over single-threaded operation. This can be true for complicated    geometries written into low-resolution rasters, but may not be for simple geometries with    high-resolution rasters. With very large rasters threading may be counter productive due    to excessing memory use. Caution should also be used: <code>threaded</code> should not be used in in-place    functions wrinting to <code>BitArray</code> or other arrays where race conditions can occur.</p> </li> <li> <p><code>filename</code>: a filename to write to directly, useful for large files.</p> </li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> </ul> <p>Example</p> <p>Rasterize a shapefile for China and plot, with a border.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates, Shapefile, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"country_borders.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Load the shapes for china\nchina_border = Shapefile.Handle(shapefile_name).shapes[10]\n\n# Rasterize the border polygon\nchina = rasterize(last, china_border; res=0.1, missingval=0, fill=1, boundary=:touches, progress=false)\n\n# And plot\np = plot(china; color=:spring, legend=false)\nplot!(p, china_border; fillalpha=0, linewidth=0.6)\n\nsavefig(\"docs/build/china_rasterized.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.rasterize!</code> \u2014 Function.</p> <pre><code>rasterize!([reducer], dest, data; kw...)\n</code></pre> <p>Rasterize the geometries in <code>data</code> into the <code>Raster</code> or <code>RasterStack</code> <code>dest</code>, using the values specified by <code>fill</code>.</p> <p>Arguments</p> <ul> <li><code>dest</code>: a <code>Raster</code> or <code>RasterStack</code> to rasterize into.</li> <li><code>reducer</code>: a reducing function to reduce the fill value for all geometries that   cover or touch a pixel down to a single value. The default is <code>last</code>.   Any  that takes an iterable and returns a single value will work, including   custom functions. However, there are optimisations for built-in methods   including <code>sum</code>, <code>first</code>, <code>last</code>, <code>minimum</code>, <code>maximum</code>, <code>extrema</code> and <code>Statistics.mean</code>.   These may be an order of magnitude or more faster than   <code>count</code> is a special-cased as it does not need a fill value.</li> <li><code>data</code>: a GeoInterface.jl <code>AbstractGeometry</code>, or a nested <code>Vector</code> of <code>AbstractGeometry</code>,   or a Tables.jl compatible object containing a <code>:geometry</code> column or points and values columns.</li> </ul> <p>Keywords</p> <p>These are detected automatically from <code>A</code> and <code>data</code> where possible.</p> <ul> <li><code>fill</code>: the value or values to fill a polygon with. A <code>Symbol</code> or tuple of <code>Symbol</code> will   be used to retrieve properties from features or column values from table rows. An array   or other iterable will be used for each geometry, in order. <code>fill</code> can also be a function of    the current value, e.g. <code>x -&gt; x + 1</code>.</li> <li><code>op</code>: A reducing function that accepts two values and returns one, like <code>min</code> to <code>minimum</code>.   For common methods this will be assigned for you, or is not required. But you can use it   instead of a <code>reducer</code> as it will usually be faster.</li> <li><code>shape</code>: force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code>, where possible   Points can't be treated as lines or polygons, and lines may not work as polygons, but   an attempt will be made.</li> <li><code>geometrycolumn</code>: <code>Symbol</code> to manually select the column the geometries are in   when <code>data</code> is a Tables.jl compatible table, or a tuple of <code>Symbol</code> for columns of   point coordinates.</li> <li><code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide..</li> <li><code>verbose</code>: print information and warnings whne there are problems with the rasterisation.   <code>true</code> by default.</li> <li> <p><code>threaded</code>: run operations in parallel, <code>false</code> by default. In some circumstances <code>threaded</code>    can give large speedups over single-threaded operation. This can be true for complicated    geometries written into low-resolution rasters, but may not be for simple geometries with    high-resolution rasters. With very large rasters threading may be counter productive due    to excessing memory use. Caution should also be used: <code>threaded</code> should not be used in in-place    functions wrinting to <code>BitArray</code> or other arrays where race conditions can occur.</p> </li> <li> <p><code>to</code>: a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code> or <code>Extents.Extent</code>.   If no <code>to</code> object is provided the extent will be calculated from the geometries,   Additionally, when no <code>to</code> object or an <code>Extent</code> is passed for <code>to</code>, the <code>size</code>   or <code>res</code> keyword must also be used.</p> </li> <li><code>res</code>: the resolution of the dimensions, a <code>Real</code> or <code>Tuple{&lt;:Real,&lt;:Real}</code>.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>size</code> is not used.</li> <li><code>size</code>: the size of the output array, as a <code>Tuple{Int,Int}</code> or single <code>Int</code> for a square.   Only required when <code>to</code> is not used or is an <code>Extents.Extent</code>, and <code>res</code> is not used.</li> <li><code>crs</code>: a <code>crs</code> which will be attached to the resulting raster when <code>to</code> not passed  or is an <code>Extent</code>. Otherwise the crs from <code>to</code> is used.</li> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code> geometries.   using points or lines as polygons may have unexpected results.</li> <li><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the polygon <code>:touches</code> the pixel, or that are completely <code>:inside</code> the polygon.   The default is <code>:center</code>.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots, Dates, Shapefile, GeoInterface, Downloads\nusing Rasters.LookupArrays\n\n# Download a borders shapefile\nshapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"country_borders.shp\"\nisfile(shapefile_name) || Downloads.download(shapefile_url, shapefile_name)\n\n# Load the shapes for indonesia\nindonesia_border = Shapefile.Handle(shapefile_name).shapes[1]\n\n# Make an empty EPSG 4326 projected Raster of the area of Indonesia\ndimz = X(Projected(90.0:0.1:145; sampling=Intervals(), crs=EPSG(4326))),\n       Y(Projected(-15.0:0.1:10.9; sampling=Intervals(), crs=EPSG(4326)))\n\nA = zeros(UInt32, dimz; missingval=UInt32(0))\n\n# Rasterize each indonesian island with a different number. The islands are\n# rings of a multi-polygon, so we use `GI.getring` to get them all separately.\nislands = collect(GeoInterface.getring(indonesia_border))\nrasterize!(last, A, islands; fill=1:length(islands), progress=false)\n\n# And plot\np = plot(Rasters.trim(A); color=:spring)\nplot!(p, indonesia_border; fillalpha=0, linewidth=0.7)\n\nsavefig(\"docs/build/indonesia_rasterized.png\"); nothing\n\n# output\n</code></pre> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.replace_missing</code> \u2014 Method.</p> <pre><code>replace_missing(a::AbstractRaster, newmissingval)\nreplace_missing(a::AbstractRasterStack, newmissingval)\n</code></pre> <p>Replace missing values in the array or stack with a new missing value, also updating the <code>missingval</code> field/s.</p> <p>Keywords</p> <ul> <li><code>filename</code>: a filename to write to directly, useful for large files.</li> <li><code>suffix</code>: a string or value to append to the filename.   A tuple of <code>suffix</code> will be applied to stack layers. <code>keys(stack)</code> are the default.</li> </ul> <p>Example</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{Climate}, :prec; month=1) |&gt; replace_missing\nmissingval(A)\n# output\nmissing\n</code></pre> <p>source</p> <p># <code>Rasters.reproject</code> \u2014 Method.</p> <pre><code>reproject(source::GeoFormat, target::GeoFormat, dim::Dimension, val)\n</code></pre> <p><code>reproject</code> uses ArchGDAL.reproject, but implemented for a reprojecting a value array of values, a single dimension at a time.</p> <p>source</p> <p># <code>Rasters.reproject</code> \u2014 Method.</p> <pre><code>reproject(obj; crs)\n</code></pre> <p>Reproject the lookups of <code>obj</code> to a different crs. </p> <p>This is a lossless operation for the raster data, as only the  lookup values change. This is only possible when the axes of source and destination projections are alligned: the change is usually from a <code>Regular</code> and an <code>Irregular</code> lookup spans.</p> <p>For converting between projections that are rotated,  skewed or warped in any way, use <code>resample</code>.</p> <p>Dimensions without an <code>AbstractProjected</code> lookup (such as a <code>Ti</code> dimension) are silently returned without modification.</p> <p>Arguments</p> <ul> <li><code>obj</code>: a <code>LookupArray</code>, <code>Dimension</code>, <code>Tuple</code> of <code>Dimension</code>, <code>Raster</code> or <code>RasterStack</code>.</li> <li><code>crs</code>: a <code>crs</code> which will be attached to the resulting raster when <code>to</code> not passed  or is an <code>Extent</code>. Otherwise the crs from <code>to</code> is used.</li> </ul> <p>source</p> <p># <code>Rasters.setcrs</code> \u2014 Method.</p> <pre><code>setcrs(x, crs)\n</code></pre> <p>Set the crs of a <code>Raster</code>, <code>RasterStack</code>, <code>Tuple</code> of <code>Dimension</code>, or a <code>Dimension</code>. The <code>crs</code> is expected to be a GeoFormatTypes.jl <code>CRS</code> or <code>Mixed</code> <code>GeoFormat</code> type</p> <p>source</p> <p># <code>Rasters.setmappedcrs</code> \u2014 Method.</p> <pre><code>setmappedcrs(x, crs)\n</code></pre> <p>Set the mapped crs of a <code>Raster</code>, a <code>RasterStack</code>, a <code>Tuple</code> of <code>Dimension</code>, or a <code>Dimension</code>. The <code>crs</code> is expected to be a GeoFormatTypes.jl <code>CRS</code> or <code>Mixed</code> <code>GeoFormat</code> type</p> <p>source</p> <p># <code>Rasters.slice</code> \u2014 Method.</p> <pre><code>slice(A::Union{AbstractRaster,AbstractRasterStack,AbstracRasterSeries}, dims) =&gt; RasterSeries\n</code></pre> <p>Slice views along some dimension/s to obtain a <code>RasterSeries</code> of the slices.</p> <p>For a <code>Raster</code> or <code>RasterStack</code> this will return a <code>RasterSeries</code> of <code>Raster</code> or <code>RasterStack</code> that are slices along the specified dimensions.</p> <p>For a <code>RasterSeries</code>, the output is another series where the child objects are sliced and the series dimensions index is now of the child dimensions combined. <code>slice</code> on a <code>RasterSeries</code> with no dimensions will slice along the dimensions shared by both the series and child object.</p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.trim</code> \u2014 Method.</p> <pre><code>trim(x; dims::Tuple, pad::Int)\n</code></pre> <p>Trim <code>missingval(x)</code> from <code>x</code> for axes in <code>dims</code>, returning a view of <code>x</code>.</p> <p>Arguments</p> <ul> <li><code>x</code>: A <code>Raster</code> or <code>RasterStack</code>. For stacks, all layers must having   missing values for a pixel for it to be trimmed.</li> </ul> <p>Keywords</p> <ul> <li><code>dims</code>: By default <code>dims=(XDim, YDim)</code>, so that trimming keeps the area    of <code>X</code> and <code>Y</code> that contains non-missing values along all other dimensions.</li> <li><code>pad</code>: The trimmed size will be padded by <code>pad</code> on all sides, although   padding will not be added beyond the original extent of the array.</li> </ul> <p>As <code>trim</code> is lazy, <code>filename</code> and <code>suffix</code> keywords are not used.</p> <p>Example</p> <p>Create trimmed layers of Australian habitat heterogeneity.</p> <pre><code>using Rasters, RasterDataSources, Plots\nlayers = (:evenness, :range, :contrast, :correlation)\nst = RasterStack(EarthEnv{HabitatHeterogeneity}, layers)\n\n# Roughly cut out australia\nausbounds = X(100 .. 160), Y(-50 .. -10)\naus = st[ausbounds...]\na = plot(aus)\n\n# Trim missing values and plot\nb = plot(trim(aus))\n\nsavefig(a, \"docs/build/trim_example_before.png\");\nsavefig(b, \"docs/build/trim_example_after.png\"); nothing\n\n# output\n</code></pre> <p>Before <code>trim</code>:</p> <p></p> <p>After <code>trim</code>:</p> <p></p> <p>WARNING: This feature is experimental. It may change in future versions, and may not be 100% reliable in all cases. Please file github issues if problems occur.</p> <p>source</p> <p># <code>Rasters.zonal</code> \u2014 Method.</p> <pre><code>zonal(f, x::Union{Raster,RasterStack}; of, kw...)\n</code></pre> <p>Calculate zonal statistics for the the zone of a <code>Raster</code> or <code>RasterStack</code> covered by the <code>of</code> object/s.</p> <p>Arguments</p> <ul> <li><code>f</code>: any function that reduces an iterable to a single value, such as <code>sum</code> or <code>Statistics.mean</code></li> <li><code>x</code>: A <code>Raster</code> or <code>RasterStack</code></li> <li><code>of</code>: A <code>Raster</code>, <code>RasterStack</code>, dim tuple, extent, GeoInterface.jl compatible geometry,   Tables.jl compatible table of a <code>:geometry</code> column, or an <code>AbstractVector</code> of   any of these objects..</li> </ul> <p>Keywords</p> <p>These can be used when <code>of</code> is a GeoInterface.jl compatible object:</p> <ul> <li><code>shape</code>: Force <code>data</code> to be treated as <code>:polygon</code>, <code>:line</code> or <code>:point</code>, where possible.</li> <li><code>boundary</code>: for polygons, include pixels where the <code>:center</code> is inside the polygon,   where the line <code>:touches</code> the pixel, or that are completely <code>:inside</code> inside the polygon.   The default is <code>:center</code>.</li> <li><code>progress</code>: show a progress bar, <code>true</code> by default, <code>false</code> to hide..</li> </ul> <p>Example</p> <p>``jldoctest using Rasters, RasterDataSources, ArchGDAL, Shapefile, DataFrames, Downloads, Statistics, Dates</p> <p>Download a borders shapefile</p> <p>neurl = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10mcultural/ne10madmin0countries\" shpurl, dbfurl  = neurl * \".shp\", neurl * \".dbf\" shpname, dbfname = \"countryborders.shp\", \"countryborders.dbf\" isfile(shpname) || Downloads.download(shpurl, shpname) isfile(dbfurl) || Downloads.download(dbfurl, dbfname)</p> <p>Download and read a raster stack from WorldClim</p> <p>st = RasterStack(WorldClim{Climate}; month=Jan, lazy=false)</p> <p>Load the shapes for world countries</p> <p>countries = Shapefile.Table(shp_name) |&gt; DataFrame</p> <p>Calculate the january mean of all climate variables for all countries</p> <p>january_stats = zonal(mean, st; of=countries, boundary=:touches, progress=false) |&gt; DataFrame</p> <p>Add the country name column (natural earth has some string errors it seems)</p> <p>insertcols!(january_stats, 1, :country =&gt; first.(split.(countries.ADMIN, r\"[^A-Za-z ]\")))</p> <p>output</p> <p>258\u00d78 DataFrame  Row \u2502 country                       tmin       tmax       tavg       prec     \u22ef      \u2502 SubStrin\u2026                     Float32    Float32    Float32    Float64  \u22ef \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    1 \u2502 Indonesia                      21.5447    29.1864    25.3656   271.063  \u22ef    2 \u2502 Malaysia                       21.3087    28.4291    24.8688   273.381    3 \u2502 Chile                           7.24534   17.9263    12.5858    78.1287    4 \u2502 Bolivia                        17.2065    27.7454    22.4759   192.542    5 \u2502 Peru                           15.0273    25.5504    20.2888   180.007  \u22ef    6 \u2502 Argentina                      13.6751    27.6715    20.6732    67.1837    7 \u2502 Dhekelia Sovereign Base Area    5.87126   15.8991    10.8868    76.25    8 \u2502 Cyprus                          5.65921   14.6665    10.1622    97.4474   \u22ee  \u2502              \u22ee                    \u22ee          \u22ee          \u22ee         \u22ee     \u22f1  252 \u2502 Spratly Islands                25.0       29.2       27.05      70.5    \u22ef  253 \u2502 Clipperton Island              21.5       33.2727    27.4        6.0  254 \u2502 Macao S                        11.6694    17.7288    14.6988    28.0  255 \u2502 Ashmore and Cartier Islands   NaN        NaN        NaN        NaN  256 \u2502 Bajo Nuevo Bank               NaN        NaN        NaN        NaN      \u22ef  257 \u2502 Serranilla Bank               NaN        NaN        NaN        NaN  258 \u2502 Scarborough Reef              NaN        NaN        NaN        NaN                                                   3 columns and 243 rows omitted ```</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/#reference-internal-functions","title":"Reference - Internal functions","text":"<p># <code>Rasters.AbstractProjected</code> \u2014 Type.</p> <pre><code>AbstractProjected &lt;: AbstractSampled\n</code></pre> <p>Abstract supertype for projected index lookups.</p> <p>source</p> <p># <code>Rasters.FileArray</code> \u2014 Type.</p> <pre><code>FileArray{X} &lt;: DiskArrays.AbstractDiskArray\n</code></pre> <p>Filearray is a DiskArrays.jl <code>AbstractDiskArray</code>. Instead of holding an open object, it just holds a filename string that is opened lazily  when it needs to be read.</p> <p>source</p> <p># <code>Rasters.FileStack</code> \u2014 Type.</p> <pre><code>FileStack{X,K}\n\nFileStack{X,K}(filename, types, sizes, eachchunk, haschunks, write)\n</code></pre> <p>A wrapper object that holds file pointer and size/chunking metadata for a multi-layered stack stored in a single file,  typically netcdf or hdf5.</p> <p><code>X</code> is a backend type like <code>NCDsource</code>, and <code>K</code> is a tuple of <code>Symbol</code> keys.</p> <p>source</p> <p># <code>Rasters.OpenStack</code> \u2014 Type.</p> <pre><code>OpenStack{X,K}\n\nOpenStack{X,K}(dataset)\n</code></pre> <p>A wrapper for any stack-like opened dataset that can be indexed with <code>Symbol</code> keys to retrieve <code>AbstractArray</code> layers.</p> <p><code>OpenStack</code> is usually hidden from users, wrapped in a regular <code>RasterStack</code> passed as the function argument in <code>open(stack)</code> when the stack is contained in a single file.</p> <p><code>X</code> is a backend type like <code>NCDsource</code>, and <code>K</code> is a tuple of <code>Symbol</code> keys.</p> <p>source</p> <p># <code>Rasters.RasterDiskArray</code> \u2014 Type.</p> <pre><code>RasterDiskArray &lt;: DiskArrays.AbstractDiskArray\n</code></pre> <p>A basic DiskArrays.jl wrapper for objects that don't have one defined yet.  When we <code>open</code> a <code>FileArray</code> it is replaced with a <code>RasterDiskArray</code>.</p> <p>source</p> <p># <code>Base.open</code> \u2014 Method.</p> <pre><code>open(f, A::AbstractRaster; write=false)\n</code></pre> <p><code>open</code> is used to open any <code>lazy=true</code> <code>AbstractRaster</code> and do multiple operations on it in a safe way. The <code>write</code> keyword opens the file in write lookup so that it can be altered on disk using e.g. a broadcast.</p> <p><code>f</code> is a method that accepts a single argument - an <code>Raster</code> object which is just an <code>AbstractRaster</code> that holds an open disk-based object. Often it will be a <code>do</code> block:</p> <p><code>lazy=false</code> (in-memory) rasters will ignore <code>open</code> and pass themselves to <code>f</code>.</p> <pre><code># A is an `Raster` wrapping the opened disk-based object.\nopen(Raster(filepath); write=true) do A\n    mask!(A; with=maskfile)\n    A[I...] .*= 2\n    # ...  other things you need to do with the open file\nend\n</code></pre> <p>By using a do block to open files we ensure they are always closed again after we finish working with them.</p> <p>source</p> <p># <code>Base.read!</code> \u2014 Method.</p> <pre><code>read!(src::Union{AbstractString,AbstractRaster}, dst::AbstractRaster)\nread!(src::Union{AbstractString,AbstractRasterStack}, dst::AbstractRasterStack)\nread!(scr::AbstractRasterSeries, dst::AbstractRasterSeries)\n</code></pre> <p><code>read!</code> will copy the data from <code>src</code> to the object <code>dst</code>. </p> <p><code>src</code> can be an object or a file-path <code>String</code>.</p> <p>source</p> <p># <code>Base.read</code> \u2014 Method.</p> <pre><code>read(A::AbstractRaster)\nread(A::AbstractRasterStack)\nread(A::AbstractRasterSeries)\n</code></pre> <p><code>read</code> will move a Rasters.jl object completely to memory.</p> <p>source</p> <p># <code>Base.skipmissing</code> \u2014 Method.</p> <pre><code>skipmissing(itr::Raster)\n</code></pre> <p>Returns an iterable over the elements in a <code>Raster</code> object, skipping any values equal to either the <code>missingval</code> or <code>missing</code>.</p> <p>source</p> <p># <code>Base.write</code> \u2014 Method.</p> <pre><code>Base.write(filepath::AbstractString, s::AbstractRasterSeries; kw...)\n</code></pre> <p>Write any <code>AbstractRasterSeries</code> to file, guessing the backend from the file extension.</p> <p>The lookup values of the series will be appended to the filepath (before the extension), separated by underscores.</p> <p>Keywords</p> <p>See other docs for <code>write</code>. All keywords are passed through to <code>Raster</code> and <code>RasterStack</code> methods.</p> <p>source</p> <p># <code>Base.write</code> \u2014 Method.</p> <pre><code>Base.write(filename::AbstractString, s::AbstractRasterStack; suffix, kw...)\n</code></pre> <p>Write any <code>AbstractRasterStack</code> to file, guessing the backend from the file extension.</p> <p>Keywords</p> <ul> <li><code>suffix</code>: suffix to append to file names. By default the layer key is used.</li> </ul> <p>Other keyword arguments are passed to the <code>write</code> method for the backend.</p> <p>If the source can't be saved as a stack-like object, individual array layers will be saved.</p> <p>source</p> <p># <code>Base.write</code> \u2014 Method.</p> <pre><code>Base.write(filename::AbstractString, A::AbstractRaster; kw...)\n</code></pre> <p>Write an <code>AbstractRaster</code> to file, guessing the backend from the file extension.</p> <p>Keyword arguments are passed to the <code>write</code> method for the backend.</p> <p>source</p> <p># <code>Base.write</code> \u2014 Method.</p> <pre><code>Base.write(filename::AbstractString, ::Type{GRDsource}, s::AbstractRaster; force=false)\n</code></pre> <p>Write a <code>Raster</code> to a .grd file with a .gri header file.  The extension of <code>filename</code> will be ignored.</p> <p>Returns <code>filename</code>.</p> <p>source</p>"},{"location":"scripts/generated/basics/array_operations/","title":"Arrays operations","text":"<p>Most base methods work as for regular julia <code>Array</code>s, such as <code>reverse</code> and rotations like <code>rotl90</code>. Base, statistics and linear algebra methods like <code>mean</code> that take a <code>dims</code> argument can also use the dimension name.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/array_operations/#mean-over-the-time-dimension","title":"Mean over the time dimension:","text":"<pre><code>using Rasters, Statistics, RasterDataSources\n\nA = Raster(WorldClim{BioClim}, 5)\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.99999999999997), Y = (-90.0, 90.0))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n           89.8333  89.6667  89.5     \u2026  -89.6667  -89.8333  -90.0\n -180.0    -3.4f38  -3.4f38  -3.4f38     -15.399   -13.805   -14.046\n -179.833  -3.4f38  -3.4f38  -3.4f38     -15.9605  -14.607   -14.5545\n -179.667  -3.4f38  -3.4f38  -3.4f38     -15.971   -14.612   -14.5685\n    \u22ee                                 \u22f1              \u22ee       \n  179.5    -3.4f38  -3.4f38  -3.4f38     -18.2955  -16.7583  -16.72\n  179.667  -3.4f38  -3.4f38  -3.4f38     -18.2847  -16.7513  -16.72\n  179.833  -3.4f38  -3.4f38  -3.4f38     -17.1478  -15.4243  -15.701\n</code></pre> <p>Then we do the meand over the <code>X</code> dimension</p> <pre><code>mean(A, dims=X) # Ti if time were available would also be possible\n</code></pre> <pre><code>1\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} -180.0:360.0:-180.0 ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 180.0), Y = (-90.0, 90.0))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n          89.8333   89.6667   89.5   89.3333  \u2026  -89.6667  -89.8333  -90.0\n -180.0  -Inf      -Inf      -Inf   -Inf         -23.0768  -22.9373  -22.0094\n</code></pre> <p><code>broadcast</code> works lazily from disk when <code>lazy=true</code>, and is only applied when data is directly indexed. Adding a dot to any function will use broadcast over a <code>Raster</code> just like an <code>Array</code>.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/array_operations/#broadcasting","title":"Broadcasting","text":"<p>For a disk-based array <code>A</code>, this will only be applied when indexing occurs or when we <code>read</code> the array.</p> <pre><code>A .*= 2\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.99999999999997), Y = (-90.0, 90.0))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n            89.8333   89.6667   89.5  \u2026  -89.6667  -89.8333  -90.0\n -180.0    -Inf      -Inf      -Inf      -30.798   -27.61    -28.092\n -179.833  -Inf      -Inf      -Inf      -31.921   -29.214   -29.109\n -179.667  -Inf      -Inf      -Inf      -31.942   -29.224   -29.137\n    \u22ee                                 \u22f1              \u22ee       \n  179.5    -Inf      -Inf      -Inf      -36.591   -33.5165  -33.44\n  179.667  -Inf      -Inf      -Inf      -36.5695  -33.5025  -33.44\n  179.833  -Inf      -Inf      -Inf      -34.2955  -30.8485  -31.402\n</code></pre> <p>To broadcast directly to disk, we need to open the file in write mode:</p> <pre><code>open(Raster(filename); write=true) do O\n   O .*= 2\nend\n</code></pre> <p>To broadcast over a <code>RasterStack</code> use <code>map</code>, which applies a function to the raster layers of the stack.</p> <pre><code>newstack = map(stack) do raster\n   raster .* 2\nend\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/array_operations/#modifying-object-properties","title":"Modifying object properties","text":"<p><code>rebuild</code> can be used to modify the fields of an object, generating a new object (but possibly holding the same arrays or files).</p> <p>If you know that a file had an incorrectly specified missing value, you can do:</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/array_operations/#rebuild","title":"rebuild","text":"<pre><code>A = Raster(WorldClim{BioClim}, 5)\nrebuild(A; missingval=-9999)\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.99999999999997), Y = (-90.0, 90.0))missingval: -9999crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n           89.8333  89.6667  89.5     \u2026  -89.6667  -89.8333  -90.0\n -180.0    -3.4f38  -3.4f38  -3.4f38     -15.399   -13.805   -14.046\n -179.833  -3.4f38  -3.4f38  -3.4f38     -15.9605  -14.607   -14.5545\n -179.667  -3.4f38  -3.4f38  -3.4f38     -15.971   -14.612   -14.5685\n    \u22ee                                 \u22f1              \u22ee       \n  179.5    -3.4f38  -3.4f38  -3.4f38     -18.2955  -16.7583  -16.72\n  179.667  -3.4f38  -3.4f38  -3.4f38     -18.2847  -16.7513  -16.72\n  179.833  -3.4f38  -3.4f38  -3.4f38     -17.1478  -15.4243  -15.701\n</code></pre> <p>(<code>replace_missing</code> will actualy replace the current values).</p> <p>Or if you need to change the name of the layer:</p> <p>Then use <code>rebuild</code> as</p> <pre><code>B = rebuild(A; name=:temperature)\nB.name\n</code></pre> <pre><code>:temperature\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/array_operations/#replace_missing","title":"replace_missing","text":"<pre><code>replace_missing(A, missingval=-9999)\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.99999999999997), Y = (-90.0, 90.0))missingval: -9999.0f0crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n              89.8333     89.6667     89.5  \u2026  -89.6667  -89.8333  -90.0\n -180.0    -9999.0     -9999.0     -9999.0     -15.399   -13.805   -14.046\n -179.833  -9999.0     -9999.0     -9999.0     -15.9605  -14.607   -14.5545\n -179.667  -9999.0     -9999.0     -9999.0     -15.971   -14.612   -14.5685\n    \u22ee                                       \u22f1              \u22ee       \n  179.5    -9999.0     -9999.0     -9999.0     -18.2955  -16.7583  -16.72\n  179.667  -9999.0     -9999.0     -9999.0     -18.2847  -16.7513  -16.72\n  179.833  -9999.0     -9999.0     -9999.0     -17.1478  -15.4243  -15.701\n</code></pre>"},{"location":"scripts/generated/basics/array_operations/#set","title":"set","text":"<p><code>set</code> can be used to modify the nested properties of an objects dimensions, that are more difficult to change with <code>rebuild</code>. <code>set</code> works on the principle that dimension properties can only be in one specific field, so we generally don't have to specify which one it is. <code>set</code> will also try to update anything affected by a change you make.</p> <p>This will set the <code>X</code> axis to specify points, instead of intervals:</p> <pre><code>using Rasters: Points\nset(A, X =&gt; Points)\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Points crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (-180.0, 179.83333333333331), Y = (-90.0, 90.0))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n           89.8333  89.6667  89.5     \u2026  -89.6667  -89.8333  -90.0\n -180.0    -3.4f38  -3.4f38  -3.4f38     -15.399   -13.805   -14.046\n -179.833  -3.4f38  -3.4f38  -3.4f38     -15.9605  -14.607   -14.5545\n -179.667  -3.4f38  -3.4f38  -3.4f38     -15.971   -14.612   -14.5685\n    \u22ee                                 \u22f1              \u22ee       \n  179.5    -3.4f38  -3.4f38  -3.4f38     -18.2955  -16.7583  -16.72\n  179.667  -3.4f38  -3.4f38  -3.4f38     -18.2847  -16.7513  -16.72\n  179.833  -3.4f38  -3.4f38  -3.4f38     -17.1478  -15.4243  -15.701\n</code></pre> <p>We can also reassign dimensions, here <code>X</code> becomes <code>Z</code>:</p> <pre><code>set(A, X =&gt; Z)\n</code></pre> <pre><code>2160\u00d71080 Raster{Float32,2} bio5 with dimensions: \n  Z Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(Z = (-180.0, 179.99999999999997), Y = (-90.0, 90.0))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n           89.8333  89.6667  89.5     \u2026  -89.6667  -89.8333  -90.0\n -180.0    -3.4f38  -3.4f38  -3.4f38     -15.399   -13.805   -14.046\n -179.833  -3.4f38  -3.4f38  -3.4f38     -15.9605  -14.607   -14.5545\n -179.667  -3.4f38  -3.4f38  -3.4f38     -15.971   -14.612   -14.5685\n    \u22ee                                 \u22f1              \u22ee       \n  179.5    -3.4f38  -3.4f38  -3.4f38     -18.2955  -16.7583  -16.72\n  179.667  -3.4f38  -3.4f38  -3.4f38     -18.2847  -16.7513  -16.72\n  179.833  -3.4f38  -3.4f38  -3.4f38     -17.1478  -15.4243  -15.701\n</code></pre> <p><code>setcrs(A, crs)</code> and <code>setmappedcrs(A, crs)</code> will set the crs value/s of an object to any <code>GeoFormat</code> from GeoFormatTypes.jl.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/data_sources/","title":"Data Sources","text":""},{"location":"scripts/generated/basics/data_sources/#data-sources","title":"Data sources","text":"<p>Rasters.jl uses a number of backends to load raster data. <code>Raster</code>, <code>RasterStack</code> and <code>RasterSeries</code> will detect which backend to use for you, automatically.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#grd","title":"GRD","text":"<p>R GRD files can be loaded natively, using Julias <code>MMap</code> - which means they are very fast, but are not compressed. They are always 3 dimensional, and have <code>Y</code>, <code>X</code> and <code>Band</code> dimensions.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#netcdf","title":"NetCDF","text":"<p>NetCDF <code>.nc</code> files are loaded using NCDatasets.jl. Layers from files can be loaded as <code>Raster(\"filename.nc\"; key=:layername)</code>. Without <code>key</code> the first layer is used. <code>RasterStack(\"filename.nc\")</code> will use all netcdf variables in the file that are not dimensions as layers.</p> <p>NetCDF layers can have arbitrary dimensions. Known, common dimension names are converted to <code>X</code>, <code>Y</code> <code>Z</code>, and <code>Ti</code>, otherwise <code>Dim{:layername}</code> is used. Layers in the same file may also have different dimensions.</p> <p>NetCDF files still have issues loading directly from disk for some operations. Using <code>read(ncstack)</code> may help.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#gdal","title":"GDAL","text":"<p>All files GDAL can access, such as <code>.tiff</code> and <code>.asc</code> files, can be loaded, using ArchGDAL.jl. These are generally best loaded as <code>Raster(\"filename.tif\")</code>, but can be loaded as <code>RasterStack(\"filename.tif\"; layersfrom=Band)</code>, taking layers from the <code>Band</code> dimension, which is also the default.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#smap","title":"SMAP","text":"<p>The Soil Moisture Active-Passive dataset provides global layers of soil moisture, temperature and other related data, in a custom HDF5 format. Layers are always 2 dimensional, with <code>Y</code> and <code>X</code> dimensions.</p> <p>These can be loaded as multi-layered <code>RasterStack(\"filename.h5\")</code>. Individual layers can be loaded as <code>Raster(\"filename.h5\"; key=:layerkey)</code>, without <code>key</code> the first layer is used.</p> <p># <code>Rasters.smapseries</code> \u2014 Function.</p> <pre><code>smapseries(filenames::AbstractString; kw...)\nsmapseries(filenames::Vector{&lt;:AbstractString}, dims=nothing; kw...)\n</code></pre> <p><code>RasterSeries</code> loader for SMAP files and whole folders of files, organised along the time dimension. Returns a <code>RasterSeries</code>.</p> <p>Arguments</p> <ul> <li><code>filenames</code>: A <code>String</code> path to a directory of SMAP files,   or a vector of <code>String</code> paths to specific files.</li> <li><code>dims</code>: <code>Tuple</code> containing <code>Ti</code> dimension for the series.   Automatically generated form <code>filenames</code> unless passed in.</li> </ul> <p>Keywords</p> <ul> <li><code>kw</code>: Passed to <code>RasterSeries</code>.</li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#writing-file-formats-to-disk","title":"Writing file formats to disk","text":"<p>Files can be written to disk in all formats other than SMAP HDF5 using <code>write(\"filename.ext\", A)</code>. See the docs for <code>write</code>. They can (with some caveats) be written to different formats than they were loaded in as, providing file-type conversion for spatial data.</p> <p>Some metadata may be lost in formats that store little metadata, or where metadata conversion has not been completely implemented.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/data_sources/#rasterdatasourcesjl-integration","title":"RasterDataSources.jl integration","text":"<p>RasterDataSources.jl standardises the download of common raster data sources, with a focus on datasets used in ecology and the environmental sciences. RasterDataSources.jl is tightly integrated into Rasters.jl, so that datsets and keywords can be used directly to download and load data as a <code>Raster</code>, <code>RasterStack</code>, or <code>RasterSeries</code>.</p> <pre><code>using Rasters, CairoMakie, Dates\nusing RasterDataSources\nA = Raster(WorldClim{Climate}, :tavg; month=June)\nMakie.plot(A)\n</code></pre> <p></p> <p>See the docs for <code>Raster</code>, <code>RasterStack</code> and <code>RasterSeries</code>, and the docs for <code>RasterDataSources.getraster</code> for syntax to specify various data sources.</p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/first_raster/","title":"Quick start","text":"<p>Quick start</p> <p>Install the package by typing:</p> <pre><code>]\nadd Rasters\n</code></pre> <p>then do</p> <pre><code>using Rasters\n</code></pre> <p>Using Rasters to read GeoTiff or NetCDF files will output something similar to the following toy examples. This is possible because Rasters.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like X, Y and Ti (time) and e.g. spatial coordinates.</p> <pre><code>using Rasters, Dates\n\nlon, lat = X(25:1:30), Y(25:1:30)\nti = Ti(DateTime(2001):Month(1):DateTime(2002))\nras = Raster(rand(lon, lat, ti)) # this generates random numbers with the dimensions given\n</code></pre> <pre><code>6\u00d76\u00d713 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2002-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2002-01-01T00:00:00\")))missingval: missingparent:\n[:, :, 1]\n     25          26          27          28         29         30\n 25   0.836143    0.535034    0.772037    0.715141   0.517193   0.196564\n 26   0.99348     0.712268    0.651809    0.774376   0.563635   0.334482\n 27   0.0426728   0.0854349   0.0479125   0.244253   0.836164   0.635506\n 28   0.15376     0.0237221   0.636022    0.269973   0.991431   0.464008\n 29   0.299324    0.458489    0.110641    0.267952   0.719993   0.374604\n 30   0.41781     0.302513    0.978251    0.84666    0.459634   0.378825\n[and 12 more slices...]\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/first_raster/#getting-the-lookup-array-from-dimensions","title":"Getting the lookup array from dimensions","text":"<pre><code>lon = lookup(ras, X) # if X is longitude\nlat = lookup(ras, Y) # if Y is latitude\n</code></pre> <pre><code>Sampled{Int64} ForwardOrdered Regular Points\nwrapping: 25:1:30\n</code></pre>"},{"location":"scripts/generated/basics/first_raster/#select-by-index","title":"Select by index","text":"<p>Selecting a time slice by index is done via</p> <pre><code>ras[Ti(1)]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))missingval: missingparent:\n     25          26          27          28         29         30\n 25   0.836143    0.535034    0.772037    0.715141   0.517193   0.196564\n 26   0.99348     0.712268    0.651809    0.774376   0.563635   0.334482\n 27   0.0426728   0.0854349   0.0479125   0.244253   0.836164   0.635506\n 28   0.15376     0.0237221   0.636022    0.269973   0.991431   0.464008\n 29   0.299324    0.458489    0.110641    0.267952   0.719993   0.374604\n 30   0.41781     0.302513    0.978251    0.84666    0.459634   0.378825\n</code></pre> <p>also</p> <pre><code>ras[Ti=1]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))missingval: missingparent:\n     25          26          27          28         29         30\n 25   0.836143    0.535034    0.772037    0.715141   0.517193   0.196564\n 26   0.99348     0.712268    0.651809    0.774376   0.563635   0.334482\n 27   0.0426728   0.0854349   0.0479125   0.244253   0.836164   0.635506\n 28   0.15376     0.0237221   0.636022    0.269973   0.991431   0.464008\n 29   0.299324    0.458489    0.110641    0.267952   0.719993   0.374604\n 30   0.41781     0.302513    0.978251    0.84666    0.459634   0.378825\n</code></pre> <p>or and interval of indices using the syntax =a:b or (a:b)</p> <pre><code>ras[Ti(1:10)]\n</code></pre> <pre><code>6\u00d76\u00d710 Raster{Float64,3} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-10-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30), Ti = (DateTime(\"2001-01-01T00:00:00\"), DateTime(\"2001-10-01T00:00:00\")))missingval: missingparent:\n[:, :, 1]\n     25          26          27          28         29         30\n 25   0.836143    0.535034    0.772037    0.715141   0.517193   0.196564\n 26   0.99348     0.712268    0.651809    0.774376   0.563635   0.334482\n 27   0.0426728   0.0854349   0.0479125   0.244253   0.836164   0.635506\n 28   0.15376     0.0237221   0.636022    0.269973   0.991431   0.464008\n 29   0.299324    0.458489    0.110641    0.267952   0.719993   0.374604\n 30   0.41781     0.302513    0.978251    0.84666    0.459634   0.378825\n[and 9 more slices...]\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/first_raster/#select-by-value","title":"Select by value","text":"<pre><code>ras[Ti=At(DateTime(2001))]\n</code></pre> <pre><code>6\u00d76 Raster{Float64,2} with dimensions: \n  X Sampled{Int64} 25:1:30 ForwardOrdered Regular Points,\n  Y Sampled{Int64} 25:1:30 ForwardOrdered Regular Points\nand reference dimensions: \n  Ti Sampled{DateTime} DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-01-01T00:00:00\") ForwardOrdered Regular Points\nextent: Extent(X = (25, 30), Y = (25, 30))missingval: missingparent:\n     25          26          27          28         29         30\n 25   0.836143    0.535034    0.772037    0.715141   0.517193   0.196564\n 26   0.99348     0.712268    0.651809    0.774376   0.563635   0.334482\n 27   0.0426728   0.0854349   0.0479125   0.244253   0.836164   0.635506\n 28   0.15376     0.0237221   0.636022    0.269973   0.991431   0.464008\n 29   0.299324    0.458489    0.110641    0.267952   0.719993   0.374604\n 30   0.41781     0.302513    0.978251    0.84666    0.459634   0.378825\n</code></pre> <p>More options are available, like <code>Near</code>, <code>Contains</code> and <code>Where</code>.</p> <p>Dimensions</p> <p>Rasters uses X, Y, and Z dimensions from <code>DimensionalData</code> to represent spatial directions like longitude,   latitude and the vertical dimension, and subset data with them. Ti is used for time, and Band represent bands.   Other dimensions can have arbitrary names, but will be treated generically.   See <code>DimensionalData</code> for more details on how they work.</p> <p>Lookup Arrays</p> <p>These specify properties of the index associated with e.g. the X and Y  dimension. Rasters.jl defines additional lookup arrays: <code>Projected</code> to handle  dimensions with projections, and <code>Mapped</code> where the projection is mapped to  another projection like <code>EPSG(4326)</code>. <code>Mapped</code> is largely designed to handle  NetCDF dimensions, especially with <code>Explicit</code> spans.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/first_raster/#subsetting-an-object","title":"Subsetting an object","text":"<p>Regular <code>getindex</code> (e.g. <code>A[1:100, :]</code>) and <code>view</code> work on all objects just as with an <code>Array</code>. <code>view</code> is always lazy, and reads from disk are deferred until <code>getindex</code> is used. <code>DimensionalData.jl</code> <code>Dimension</code>s and <code>Selector</code>s are the other way to subset an object, making use of the objects index to find values at e.g. certain <code>X/Y</code> coordinates. The available selectors are listed here:</p> Selectors Description <code>At(x)</code> get the index exactly matching the passed in value(s). <code>Near(x)</code> get the closest index to the passed in value(s). <code>Where(f::Function)</code> filter the array axis by a function of the dimension index values. <code>a..b</code>/<code>Between(a, b)</code> get all indices between two values, excluding the high value. <code>Contains(x)</code> get indices where the value x falls within an interval. <p>Info</p> <ul> <li>Use the <code>..</code> selector to take a view of madagascar:</li> </ul> <pre><code>using Rasters, RasterDataSources\nconst RS = Rasters\nusing CairoMakie\nCairoMakie.activate!()\n\nA = Raster(WorldClim{BioClim}, 5)\nmadagascar = view(A, X(43.25 .. 50.48), Y(-25.61 .. -12.04))\n</code></pre> <pre><code>42\u00d780 Raster{Float32,2} bio5 with dimensions: \n  X Projected{Float64} LinRange{Float64}(43.3333, 50.1667, 42) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(-12.3333, -25.5, 80) ReverseOrdered Regular Intervals crs: WellKnownText\nand reference dimensions: \n  Band Categorical{Int64} 1:1 ForwardOrdered\nextent: Extent(X = (43.33333333333334, 50.333333333333336), Y = (-25.5, -12.166666666666677))missingval: -3.4f38crs: GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]\nparent:\n          -12.3333  -12.5     -12.6667  \u2026  -25.1667  -25.3333  -25.5\n 43.3333   -3.4f38   -3.4f38   -3.4f38      -3.4f38   -3.4f38   -3.4f38\n 43.5      29.7175   30.5      -3.4f38      -3.4f38   -3.4f38   -3.4f38\n 43.6667   29.272    29.7587   -3.4f38      -3.4f38   -3.4f38   -3.4f38\n  \u22ee                                     \u22f1              \u22ee       \n 49.8333   -3.4f38   -3.4f38   -3.4f38      -3.4f38   -3.4f38   -3.4f38\n 50.0      -3.4f38   -3.4f38   -3.4f38      -3.4f38   -3.4f38   -3.4f38\n 50.1667   -3.4f38   -3.4f38   -3.4f38      -3.4f38   -3.4f38   -3.4f38\n</code></pre> <p>Note the space between .. -12</p> <pre><code>Makie.plot(madagascar)\n</code></pre> <p></p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/gbif_wflow/","title":"A basic species distribution modelling workflow","text":"<p>Load occurrences for the Mountain Pygmy Possum using GBIF.jl</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/gbif_wflow/#load","title":"Load","text":"<pre><code>using Rasters, GBIF2\nusing RasterDataSources\nconst RS = Rasters\n\nrecords = GBIF2.occurrence_search(\"Burramys parvus\"; limit=300)\n</code></pre> <pre><code>300-element GBIF2.Table{GBIF2.Occurrence, JSON3.Array{JSON3.Object, Vector{UInt8}, SubArray{UInt64, 1, Vector{UInt64}, Tuple{UnitRange{Int64}}, true}}}\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 decimalLongitude \u2502 decimalLatitude \u2502    year \u2502   month \u2502     day \u2502  kingdom  \u22ef\n\u2502         Float64? \u2502        Float64? \u2502  Int64? \u2502  Int64? \u2502  Int64? \u2502  String?  \u22ef\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502          missing \u2502         missing \u2502 missing \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          missing \u2502         missing \u2502    2021 \u2502       1 \u2502       6 \u2502 Animalia  \u22ef\n\u2502          148.391 \u2502        -36.3036 \u2502    2015 \u2502      11 \u2502      15 \u2502 Animalia  \u22ef\n\u2502          148.396 \u2502        -36.3818 \u2502    2016 \u2502      11 \u2502      15 \u2502 Animalia  \u22ef\n\u2502          148.333 \u2502        -36.4333 \u2502    2011 \u2502      11 \u2502      21 \u2502 Animalia  \u22ef\n\u2502            147.1 \u2502           -37.0 \u2502    2008 \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          148.329 \u2502        -36.4317 \u2502    2016 \u2502       1 \u2502       3 \u2502 Animalia  \u22ef\n\u2502          missing \u2502         missing \u2502 missing \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          148.236 \u2502        -36.5249 \u2502    2012 \u2502      11 \u2502      23 \u2502 Animalia  \u22ef\n\u2502          147.096 \u2502        -36.9357 \u2502    2020 \u2502       2 \u2502      10 \u2502 Animalia  \u22ef\n\u2502          missing \u2502         missing \u2502 missing \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          148.241 \u2502        -36.4001 \u2502    2011 \u2502      11 \u2502      18 \u2502 Animalia  \u22ef\n\u2502          missing \u2502         missing \u2502 missing \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          missing \u2502         missing \u2502 missing \u2502 missing \u2502 missing \u2502 Animalia  \u22ef\n\u2502          148.347 \u2502        -36.5047 \u2502    2012 \u2502      11 \u2502      22 \u2502 Animalia  \u22ef\n\u2502        \u22ee         \u2502        \u22ee        \u2502    \u22ee    \u2502    \u22ee    \u2502    \u22ee    \u2502    \u22ee      \u22f1\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                                 77 columns and 285 rows omitted\n</code></pre>"},{"location":"scripts/generated/basics/gbif_wflow/#extract-coordinates","title":"Extract coordinates","text":"<p>Extract the longitude/latitude value to a <code>Vector</code> of points (a <code>Tuple</code> counts as a <code>(x, y)</code> point in GeoInterface.jl):</p> <pre><code>coords = [(r.decimalLongitude, r.decimalLatitude) for r in records if !ismissing(r.decimalLatitude)]\n</code></pre> <pre><code>253-element Vector{Tuple{Float64, Float64}}:\n (148.391097, -36.30362)\n (148.396453, -36.381847)\n (148.332969, -36.433349)\n (147.1, -37.0)\n (148.328896, -36.431684)\n (148.235596, -36.524924)\n (147.096394, -36.935687)\n (148.240881, -36.400058)\n (148.347186, -36.504673)\n (151.250866, -33.831883)\n \u22ee\n (147.1602, -36.9601)\n (147.3096, -36.8901)\n (147.1602, -36.9601)\n (147.1602, -36.9601)\n (147.1467, -36.9854)\n (147.1647, -36.9583)\n (147.1602, -36.9601)\n (147.2429, -36.9068)\n (148.459399, -36.00639)\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/gbif_wflow/#get-layer-band","title":"Get layer / Band","text":"<p>Get BioClim layers and subset to south-east Australia</p> <pre><code>A = RasterStack(WorldClim{BioClim}, (1, 3, 7, 12))\nse_aus = A[X(138 .. 155), Y(-40 .. -25), RS.Band(1)]\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(138.0, 154.833, 102) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(-25.1667, -39.8333, 89) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :bio1  Float32 dims: X, Y (102\u00d789)\n  :bio3  Float32 dims: X, Y (102\u00d789)\n  :bio7  Float32 dims: X, Y (102\u00d789)\n  :bio12 Float32 dims: X, Y (102\u00d789)\n</code></pre> <p>Plot BioClim predictors and scatter occurrence points on all subplots</p> <pre><code>using Plots\np = plot(se_aus);\nkw = (legend=:none, opacity=0.5, markershape=:cross, markercolor=:black)\nforeach(i -&gt; scatter!(p, coords; subplot=i, kw...), 1:4)\np\n</code></pre> <p> </p> <p>Then extract predictor variables and write to CSV.</p> <pre><code>using CSV\npredictors = collect(extract(se_aus, coords))\nCSV.write(\"burramys_parvus_predictors.csv\", predictors)\n</code></pre> <pre><code>\"burramys_parvus_predictors.csv\"\n</code></pre> <p>Or convert them to a <code>DataFrame</code>:</p> <pre><code>using DataFrames\ndf = DataFrame(predictors)\ndf[1:5, :]\n</code></pre> 5\u00d75 DataFrame Rowgeometrybio1bio3bio7bio12Tuple\u2026Float32Float32Float32Float321(148.391, -36.3036)6.170741.119823.46451692.02(148.396, -36.3818)6.8815842.268123.1331544.03(148.333, -36.4333)7.8357241.597523.50281500.04(147.1, -37.0)9.4083540.790523.08951292.05(148.329, -36.4317)7.8357241.597523.50281500.0 <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/methods/","title":"Methods","text":""},{"location":"scripts/generated/basics/methods/#methods-that-change-the-resolution-or-extent-of-an-object","title":"Methods that change the resolution or extent of an object","text":"<p>Click through to the function documentation for more in-depth descriptions and examples.</p> Methods Description <code>aggregate</code> aggregate data by the same or different amounts for each axis. <code>disaggregate</code> similarly disaggregate data. <code>mosaic</code> join rasters covering different extents into a single array or file. <code>crop</code> shrink objects to specific dimension sizes or the extent of another object. <code>extend</code> extend objects to specific dimension sizes or the extent of another object. <code>trim</code> trims areas of missing values for arrays and across stack layers. <code>resample</code> resample data to a different size and projection, or snap to another object. <code>warp</code> use <code>gdalwarp</code> on any object, e.g. a multidimensional NetCDF stack. <p></p> <p></p>"},{"location":"scripts/generated/basics/methods/#methods-that-change-an-objects-values","title":"Methods that change an objects values","text":"<p>Info</p> <p>Note that most regular Julia methods, such as <code>replace</code>, work as for a standard   <code>Array</code>. These additional methods are commonly required in GIS applications.</p> Methods Description <code>classify</code> classify values into categories. <code>mask</code> mask an object by a polygon or <code>Raster</code> along <code>X/Y</code>, or other dimensions. <code>replace_missing</code> replace all missing values in an object and update <code>missingval</code>. <p></p> <p></p>"},{"location":"scripts/generated/basics/methods/#point-polygon-and-table-operation","title":"Point, polygon and table operation","text":"Methods Description <code>rasterize</code> rasterize points and geometries. <code>extract</code> extract values from points or geometries. <code>zonal</code> calculate zonal statistics for an object masked by geometries."},{"location":"scripts/generated/basics/methods/#methods-to-load-write-and-modify-data-sources","title":"Methods to load, write and modify data sources","text":"Methods Description <code>modify</code> replace the data in objects. Useful to e.g. move objects to/from a GPU. <code>read</code> read data to memory if it is on disk. <code>read!</code> read data to predefined memory. <code>open</code> open the underlying data for manually reading or writing. <code>write</code> write objects to file. <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/plot_makie/","title":"Examples with Makie","text":""},{"location":"scripts/generated/basics/plot_makie/#plotting-in-makie","title":"Plotting in Makie","text":"<p>Plotting in Makie works somewhat differently than Plots, since the recipe system is different. You can pass a 2-D raster to any surface-like function (heatmap, contour, contourf, or even surface for a 3D plot) with ease.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/plot_makie/#2-d-rasters-in-makie","title":"2-D rasters in Makie","text":"<pre><code>using CairoMakie, Makie\nusing Rasters, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{BioClim}, 5) # this is a 3D raster, so is not accepted.\n\nfig = Figure()\nplot(fig[1, 1], A)\ncontour(fig[1, 2], A)\nax = Axis(fig[2, 1]; aspect = DataAspect())\ncontourf!(ax, A)\nsurface(fig[2, 2], A) # even a 3D plot works!\nfig\n</code></pre>"},{"location":"scripts/generated/basics/plot_makie/#3-d-rasters-in-makie","title":"3-D rasters in Makie","text":"<p>Warning</p> <p>This interface is experimental, and unexported for that reason.  It may break at any time!</p> <p>Just as in Plots, 3D rasters are treated as a series of 2D rasters, which are tiled and plotted.</p> <p>You can use <code>Rasters.rplot</code> to visualize 3D rasters or RasterStacks in this way.  An example is below:</p> <pre><code>stack = RasterStack(WorldClim{Climate}; month = 1)\nRasters.rplot(stack; Axis = (aspect = DataAspect(),),)\n</code></pre> <p></p> <p>You can pass any theming keywords in, which are interpreted by Makie appropriately.</p> <p>The plots seem a little squished here.  We provide a Makie theme which makes text a little smaller and has some other space-efficient attributes:</p> <pre><code>Makie.set_theme!(Rasters.theme_rasters())\nRasters.rplot(stack)\n</code></pre> <p></p> <p>reset theme</p> <pre><code>Makie.set_theme!()\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/plot_makie/#plotting-with-observables-animations","title":"Plotting with <code>Observable</code>s, animations","text":"<p><code>Rasters.rplot</code> should support Observable input out of the box, but the dimensions of that input must remain the same - i.e., the element names of a RasterStack must remain the same.</p> <pre><code>Makie.set_theme!(Rasters.theme_rasters())\n</code></pre> <p><code>stack</code> is the WorldClim climate data for January</p> <pre><code>stack_obs = Observable(stack)\nfig = Rasters.rplot(stack_obs;\n    Colorbar=(; height=Relative(0.75), width=5)\n)\nrecord(fig, \"rplot.mp4\", 1:12; framerate = 3) do i\n    stack_obs[] = RasterStack(WorldClim{Climate}; month = i)\nend\n</code></pre> <pre><code>\"rplot.mp4\"\n</code></pre> <p></p> <pre><code>Makie.set_theme!() # reset theme\n</code></pre> <p># <code>Rasters.rplot</code> \u2014 Function.</p> <pre><code>Rasters.rplot([position::GridPosition], raster; kw...)\n</code></pre> <p><code>raster</code> may be a <code>Raster</code> (of 2 or 3 dimensions) or a <code>RasterStack</code> whose underlying rasters are 2 dimensional, or 3-dimensional with a singleton (length-1) third dimension.</p> <p>Keywords</p> <ul> <li><code>plottype = Makie.Heatmap</code>: The type of plot. Can be any Makie plot type which accepts a <code>Raster</code>; in practice, <code>Heatmap</code>, <code>Contour</code>, <code>Contourf</code> and <code>Surface</code> are the best bets.</li> <li><code>axistype = Makie.Axis</code>: The type of axis. This can be an <code>Axis</code>, <code>Axis3</code>, <code>LScene</code>, or even a <code>GeoAxis</code> from GeoMakie.jl.</li> <li><code>X = XDim</code>: The X dimension of the raster.</li> <li><code>Y = YDim</code>: The Y dimension of the raster.</li> <li><code>Z = YDim</code>: The Y dimension of the raster.</li> <li><code>draw_colorbar = true</code>: Whether to draw a colorbar for the axis or not.</li> <li><code>colorbar_position = Makie.Right()</code>: Indicates which side of the axis the colorbar should be placed on.  Can be <code>Makie.Top()</code>, <code>Makie.Bottom()</code>, <code>Makie.Left()</code>, or <code>Makie.Right()</code>.</li> <li><code>colorbar_padding = Makie.automatic</code>: The amound of padding between the colorbar and its axis.  If <code>automatic</code>, then this is set to the width of the colorbar.</li> <li><code>title = Makie.automatic</code>: The titles of each plot. If <code>automatic</code>, these are set to the name of the band.</li> <li><code>xlabel = Makie.automatic</code>: The x-label for the axis. If <code>automatic</code>, set to the dimension name of the X-dimension of the raster.</li> <li><code>ylabel = Makie.automatic</code>: The y-label for the axis. If <code>automatic</code>, set to the dimension name of the Y-dimension of the raster.</li> <li><code>colorbarlabel = \"\"</code>: Usually nothing, but here if you need it. Sets the label on the colorbar.</li> <li><code>colormap = nothing</code>: The colormap for the heatmap. This can be set to a vector of colormaps (symbols, strings, <code>cgrad</code>s) if plotting a 3D raster or RasterStack.</li> <li><code>colorrange = Makie.automatic</code>: The colormap for the heatmap.  This can be set to a vector of <code>(low, high)</code> if plotting a 3D raster or RasterStack.</li> <li><code>nan_color = :transparent</code>: The color which <code>NaN</code> values should take. Default to transparent.</li> </ul> <p>source</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/plot_makie/#using-vanilla-makie","title":"Using vanilla Makie","text":"<pre><code>using Rasters, RasterDataSources\n</code></pre> <p>The data</p> <pre><code>layers = (:evenness, :range, :contrast, :correlation)\nst = RasterStack(EarthEnv{HabitatHeterogeneity}, layers)\nausbounds = X(100 .. 160), Y(-50 .. -10) # Roughly cut out australia\naus = st[ausbounds...] |&gt; Rasters.trim\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(113.333, 153.542, 194) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(-10.2083, -43.5417, 161) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :evenness    UInt16 dims: X, Y (194\u00d7161)\n  :range       UInt16 dims: X, Y (194\u00d7161)\n  :contrast    UInt32 dims: X, Y (194\u00d7161)\n  :correlation UInt16 dims: X, Y (194\u00d7161)\n</code></pre> <p>The plot colorbar attributes</p> <pre><code>colormap = :batlow\nflipaxis = false\ntickalign=1\nwidth = 13\nticksize = 13\n</code></pre> <pre><code>13\n</code></pre> <p>figure</p> <pre><code>with_theme(theme_ggplot2()) do\n    fig = Figure(resolution=(800, 600))\n    axs = [Axis(fig[i,j], xlabel = \"lon\", ylabel = \"lat\") for i in 1:2 for j in 1:2]\n    plt = [Makie.heatmap!(axs[i], aus[l]; colormap) for (i, l) in enumerate(layers)]\n    for (i, l) in enumerate(layers) axs[i].title = string(l) end\n    hidexdecorations!.(axs[1:2]; grid=false, ticks=false)\n    hideydecorations!.(axs[[2,4]]; grid=false, ticks=false)\n    Colorbar(fig[1, 0], plt[1]; flipaxis, tickalign, width, ticksize)\n    Colorbar(fig[1, 3], plt[2]; tickalign, width, ticksize)\n    Colorbar(fig[2, 0], plt[3]; flipaxis, tickalign, width, ticksize)\n    Colorbar(fig[2, 3], plt[4]; tickalign, width, ticksize)\n    colgap!(fig.layout, 5)\n    rowgap!(fig.layout, 5)\n    Label(fig[0, :], \"RasterStack of EarthEnv HabitatHeterogeneity layers, trimmed to Australia\")\n    fig\nend\nsave(\"aus_trim.png\", current_figure());\n</code></pre> <p></p> <p>This page was generated using Literate.jl.</p>"},{"location":"scripts/generated/basics/plotting/","title":"Examples and Plotting","text":""},{"location":"scripts/generated/basics/plotting/#plots-simple","title":"Plots, simple","text":"<p><code>Plots.jl</code> and <code>Makie.jl</code> are fully supported by Rasters.jl, with recipes for plotting <code>Raster</code> and <code>RasterStack</code> provided. <code>plot</code> will plot a heatmap with axes matching dimension values. If <code>mappedcrs</code> is used, converted values will be shown on axes instead of the underlying <code>crs</code> values. <code>contourf</code> will similarly plot a filled contour plot.</p> <p>Pixel resolution is limited to allow loading very large files quickly. <code>max_res</code> specifies the maximum pixel resolution to show on the longest axis of the array. It can be set manually to change the resolution (e.g. for large or high-quality plots):</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Plots\nA = Raster(WorldClim{BioClim}, 5)\nplot(A; max_res=3000)\n</code></pre> <p> </p> <p>For Makie, <code>plot</code> functions in a similar way.  <code>plot</code> will only accept two-dimensional rasters. You can invoke <code>contour</code>, <code>contourf</code>, <code>heatmap</code>, <code>surface</code> or any Makie plotting function which supports surface-like data on a 2D raster.</p> <p>To obtain tiled plots for 3D rasters and RasterStacks, use the function <code>Rasters.rplot([gridposition], raster; kw_args...)</code>. This is an unexported function, since we're not sure how the API will change going forward.</p> <p></p> <p></p>"},{"location":"scripts/generated/basics/plotting/#makie-simple","title":"Makie, simple","text":"<pre><code>using CairoMakie\nCairoMakie.activate!(px_per_unit = 2)\nusing Rasters, CairoMakie, RasterDataSources, ArchGDAL\nA = Raster(WorldClim{BioClim}, 5)\nMakie.plot(A)\n</code></pre>"},{"location":"scripts/generated/basics/plotting/#loading-data","title":"Loading data","text":"<p>Our first example simply loads a file from disk and plots it.</p> <p>This <code>netcdf</code> file only has one layer, if it has more we could use RasterStack instead.</p> <pre><code>using Rasters, NCDatasets, Plots\nurl = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\nfilename = download(url, \"tos_O1_2001-2002.nc\");\nA = Raster(filename)\n</code></pre> <pre><code>180\u00d7170\u00d724 Raster{Union{Missing, Float32},3} tos with dimensions: \n  X Mapped{Float64} Float64[1.0, 3.0, \u2026, 357.0, 359.0] ForwardOrdered Explicit Intervals crs: EPSG mappedcrs: EPSG,\n  Y Mapped{Float64} Float64[-79.5, -78.5, \u2026, 88.5, 89.5] ForwardOrdered Explicit Intervals crs: EPSG mappedcrs: EPSG,\n  Ti Sampled{DateTime360Day} DateTime360Day[DateTime360Day(2001-01-16T00:00:00), \u2026, DateTime360Day(2002-12-16T00:00:00)] ForwardOrdered Explicit Intervals\nextent: Extent(X = (-0.0, 360.0), Y = (-80.0, 90.0), Ti = (DateTime360Day(2001-01-01T00:00:00), DateTime360Day(2003-01-01T00:00:00)))missingval: missingcrs: EPSG:4326\nmappedcrs: EPSG:4326\nparent:\n[:, :, 1]\n        -79.5       -78.5       \u2026   86.5     87.5     88.5     89.5\n   1.0     missing     missing     271.43   271.437  271.445  271.459\n   3.0     missing     missing     271.431  271.438  271.445  271.459\n   5.0     missing     missing     271.431  271.438  271.445  271.459\n   7.0     missing     missing     271.431  271.439  271.446  271.459\n   \u22ee                            \u22f1                      \u22ee      \n 351.0     missing     missing     271.43   271.435  271.445  271.459\n 353.0     missing     missing     271.43   271.436  271.445  271.459\n 355.0     missing     missing     271.43   271.436  271.445  271.459\n 357.0     missing     missing     271.43   271.437  271.445  271.459\n 359.0     missing     missing  \u2026  271.43   271.437  271.445  271.459\n[and 23 more slices...]\n</code></pre> <p>Objects with Dimensions other than X and Y will produce multi-pane plots. Here we plot every third month in the first year in one plot:</p> <pre><code>A[Ti=1:3:12] |&gt; plot\n</code></pre> <p> </p> <p>Now plot the ocean temperatures around the Americas in the first month of 2001. Notice we are using lat/lon coordinates and date/time instead of regular indices. The time dimension uses <code>DateTime360Day</code>, so we need to load CFTime.jl to index it with <code>Near</code>.</p> <pre><code>using CFTime\nA[Ti(Near(DateTime360Day(2001, 01, 17))), Y(-60.0 .. 90.0), X(45.0 .. 190.0)] |&gt; plot\n</code></pre> <p> </p> <p>Now get the mean over the timespan, then save it to disk, and plot it as a filled contour.</p> <p>Other plot functions and sliced objects that have only one <code>X</code>/<code>Y</code>/<code>Z</code> dimension fall back to generic DimensionalData.jl plotting, which will still correctly label plot axes.</p> <pre><code>using Statistics\n# Take the mean\nmean_tos = mean(A; dims=Ti)\n</code></pre> <pre><code>180\u00d7170\u00d71 Raster{Union{Missing, Float32},3} tos with dimensions: \n  X Mapped{Float64} Float64[1.0, 3.0, \u2026, 357.0, 359.0] ForwardOrdered Explicit Intervals crs: EPSG mappedcrs: EPSG,\n  Y Mapped{Float64} Float64[-79.5, -78.5, \u2026, 88.5, 89.5] ForwardOrdered Explicit Intervals crs: EPSG mappedcrs: EPSG,\n  Ti Sampled{DateTime360Day} DateTime360Day(2002-01-16T00:00:00):Millisecond(2592000000):DateTime360Day(2002-01-16T00:00:00) ForwardOrdered Explicit Intervals\nextent: Extent(X = (-0.0, 360.0), Y = (-80.0, 90.0), Ti = (DateTime360Day(2001-01-01T00:00:00), DateTime360Day(2003-01-01T00:00:00)))missingval: missingcrs: EPSG:4326\nmappedcrs: EPSG:4326\nparent:\n[:, :, 1]\n        -79.5       -78.5       \u2026   86.5     87.5     88.5     89.5\n   1.0     missing     missing     271.427  271.434  271.443  271.454\n   3.0     missing     missing     271.427  271.434  271.443  271.454\n   5.0     missing     missing     271.427  271.434  271.443  271.454\n   7.0     missing     missing     271.427  271.435  271.444  271.454\n   \u22ee                            \u22f1                      \u22ee      \n 351.0     missing     missing     271.427  271.433  271.443  271.454\n 353.0     missing     missing     271.427  271.433  271.443  271.454\n 355.0     missing     missing     271.427  271.433  271.443  271.454\n 357.0     missing     missing     271.427  271.433  271.443  271.454\n 359.0     missing     missing  \u2026  271.427  271.433  271.443  271.454\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/plotting/#plot-a-contour-plot","title":"Plot a contour plot","text":"<pre><code>using Plots\nPlots.contourf(mean_tos; dpi=300, size=(800, 400))\n</code></pre>"},{"location":"scripts/generated/basics/plotting/#write-to-disk","title":"write to disk","text":"<p>Write the mean values to disk</p> <pre><code>write(\"mean_tos.nc\", mean_tos)\n</code></pre> <pre><code>\"mean_tos.nc\"\n</code></pre> <p>Plotting recipes in DimensionalData.jl are the fallback for Rasters.jl when the object doesn't have 2 <code>X</code>/<code>Y</code>/<code>Z</code> dimensions, or a non-spatial plot command is used. So (as a random example) we could plot a transect of ocean surface temperature at 20 degree latitude :</p> <pre><code>A[Y(Near(20.0)), Ti(1)] |&gt; plot\n</code></pre> <p> </p> <p></p> <p></p>"},{"location":"scripts/generated/basics/plotting/#polygon-masking-mosaic-and-plot","title":"Polygon masking, mosaic and plot","text":"<p>In this example we will <code>mask</code> the Scandinavian countries with border polygons, then <code>mosaic</code> together to make a single plot.</p> <p>First, get the country boundary shape files using GADM.jl.</p> <pre><code>using Rasters, RasterDataSources, ArchGDAL, Shapefile, Plots, Dates, Downloads, NCDatasets\n</code></pre> <pre><code>WARNING: using Downloads.download in module Main conflicts with an existing identifier.\n</code></pre> <p>Download the shapefile</p> <pre><code>shapefile_url = \"https://github.com/nvkelso/natural-earth-vector/raw/master/10m_cultural/ne_10m_admin_0_countries.shp\"\nshapefile_name = \"boundary_lines.shp\"\nDownloads.download(shapefile_url, shapefile_name)\n</code></pre> <pre><code>\"boundary_lines.shp\"\n</code></pre> <p>Load using Shapefile.jl</p> <pre><code>shapes = Shapefile.Handle(shapefile_name)\ndenmark_border = shapes.shapes[71]\nnorway_border = shapes.shapes[53]\nsweden_border = shapes.shapes[54]\n</code></pre> <pre><code>Polygon(4665 Points)\n</code></pre> <p>Then load raster data. We load some worldclim layers using <code>RasterDataSources</code> via Rasters.jl:</p> <pre><code>climate = RasterStack(WorldClim{Climate}, (:tmin, :tmax, :prec, :wind); month=July)\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :tmin Float32 dims: X, Y (2160\u00d71080)\n  :tmax Float32 dims: X, Y (2160\u00d71080)\n  :prec Int16 dims: X, Y (2160\u00d71080)\n  :wind Float32 dims: X, Y (2160\u00d71080)\n</code></pre> <p><code>mask</code> Denmark, Norway and Sweden from the global dataset using their border polygon, then trim the missing values. We pad <code>trim</code> with a 10 pixel margin.</p> <pre><code>mask_trim(climate, poly) = trim(mask(climate; with=poly); pad=10)\n\ndenmark = mask_trim(climate, denmark_border)\nnorway = mask_trim(climate, norway_border)\nsweden = mask_trim(climate, sweden_border)\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(9.5, 25.6667, 98) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(70.5, 53.6667, 102) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :tmin Float32 dims: X, Y (98\u00d7102)\n  :tmax Float32 dims: X, Y (98\u00d7102)\n  :prec Int16 dims: X, Y (98\u00d7102)\n  :wind Float32 dims: X, Y (98\u00d7102)\n</code></pre> <p>Then load raster data. We load some worldclim layers using <code>RasterDataSources</code> via Rasters.jl:</p> <pre><code>climate = RasterStack(WorldClim{Climate}, (:tmin, :tmax, :prec, :wind); month=July)\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(-180.0, 179.833, 2160) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(89.8333, -90.0, 1080) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :tmin Float32 dims: X, Y (2160\u00d71080)\n  :tmax Float32 dims: X, Y (2160\u00d71080)\n  :prec Int16 dims: X, Y (2160\u00d71080)\n  :wind Float32 dims: X, Y (2160\u00d71080)\n</code></pre> <p><code>mask</code> Denmark, Norway and Sweden from the global dataset using their border polygon, then trim the missing values. We pad <code>trim</code> with a 10 pixel margin.</p> <pre><code>mask_trim(climate, poly) = trim(mask(climate; with=poly); pad=10)\n\ndenmark = mask_trim(climate, denmark_border)\nnorway = mask_trim(climate, norway_border)\nsweden = mask_trim(climate, sweden_border)\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} LinRange{Float64}(9.5, 25.6667, 98) ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} LinRange{Float64}(70.5, 53.6667, 102) ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :tmin Float32 dims: X, Y (98\u00d7102)\n  :tmax Float32 dims: X, Y (98\u00d7102)\n  :prec Int16 dims: X, Y (98\u00d7102)\n  :wind Float32 dims: X, Y (98\u00d7102)\n</code></pre> <p></p> <p></p>"},{"location":"scripts/generated/basics/plotting/#plotting-with-plots","title":"Plotting with Plots","text":"<p>First define a function to add borders to all subplots.</p> <pre><code>function borders!(p, poly)\n    for i in 1:length(p)\n        Plots.plot!(p, poly; subplot=i, fillalpha=0, linewidth=0.6)\n    end\n    return p\nend\n</code></pre> <pre><code>borders! (generic function with 1 method)\n</code></pre> <p>Now we can plot the individual countries.</p> <pre><code>dp = plot(denmark)\nborders!(dp, denmark_border)\n</code></pre> <p> </p> <p>and sweden</p> <pre><code>sp = plot(sweden)\nborders!(sp, sweden_border)\n</code></pre> <p> </p> <p>and norway</p> <pre><code>np = plot(norway)\nborders!(np, norway_border)\n</code></pre> <p> </p> <p>The Norway shape includes a lot of islands. Lets crop them out using <code>..</code> intervals:</p> <pre><code>norway_region = climate[X(0..40), Y(55..73)]\nplot(norway_region)\n</code></pre> <p> </p> <p>And mask it with the border again:</p> <pre><code>norway = mask_trim(norway_region, norway_border)\nnp = plot(norway)\nborders!(np, norway_border)\n</code></pre> <p> </p> <p>Now we can combine the countries into a single raster using mosaic. first will take the first value if/when there is an overlap.</p> <pre><code>scandinavia = mosaic(first, denmark, norway, sweden)\n</code></pre> <pre><code>RasterStack with dimensions: \n  X Projected{Float64} 3.1666666666666443:0.16666666666666666:32.49999999999998 ForwardOrdered Regular Intervals crs: WellKnownText,\n  Y Projected{Float64} 72.66666666666666:-0.16666666666666666:52.99999999999999 ReverseOrdered Regular Intervals crs: WellKnownText\nand 4 layers:\n  :tmin Float32 dims: X, Y (177\u00d7119)\n  :tmax Float32 dims: X, Y (177\u00d7119)\n  :prec Int16 dims: X, Y (177\u00d7119)\n  :wind Float32 dims: X, Y (177\u00d7119)\n</code></pre> <p>And plot scandinavia, with all borders included:</p> <pre><code>p = plot(scandinavia)\nborders!(p, denmark_border)\nborders!(p, norway_border)\nborders!(p, sweden_border)\np\n</code></pre> <p> </p> <p>And save to <code>netcdf</code> - a single multi-layered file, and <code>tif</code>, which will write a file for each stack layer.</p> <pre><code>write(\"scandinavia.nc\", scandinavia)\nwrite(\"scandinavia.tif\", scandinavia)\n</code></pre> <pre><code>(tmin = \"scandinavia_tmin.tif\", tmax = \"scandinavia_tmax.tif\", prec = \"scandinavia_prec.tif\", wind = \"scandinavia_wind.tif\")\n</code></pre> <p><code>Rasters.jl</code> provides a range of other methods that are being added to over time. Where applicable these methods read and write lazily to and from disk-based arrays of common raster file types. These methods also work for entire RasterStacks and RasterSeries using the same syntax.</p> <p>This page was generated using Literate.jl.</p>"}]}